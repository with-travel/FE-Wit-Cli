name: Release to TestFlight

on:
  pull_request_target:
    types: [opened, ready_for_review]
    branches:
      - 'release'

permissions:
  contents: write
  pull-requests: write

jobs:
  # ===============================================================
  # Job 1: Build Test
  # PR의 코드가 정상적으로 빌드되는지 확인합니다.
  # ===============================================================
  build-test:
    name: 🧪 Build Test
    if: github.head_ref == 'main'
    runs-on: macos-14
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install JS dependencies
        run: npm ci

      - name: Select Xcode 16
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'

      - name: Install CocoaPods
        run: |
          gem install cocoapods -N
          cd ios && pod install --repo-update

      - name: Build iOS (Simulator)
        env:
          RCT_NO_LAUNCH_PACKAGER: '1'
        run: |
          xcodebuild \
            -workspace ios/Wit.xcworkspace \
            -scheme Wit \
            -configuration Release \
            -sdk iphonesimulator \
            -destination 'platform=iOS Simulator,name=iPhone SE (3rd generation)' \
            -derivedDataPath build \
            clean build

  # ===============================================================
  # Job 2: Prepare Release
  # 버전/체인지로그 업데이트, PR 병합 및 Git 태그 생성을 담당합니다.
  # ===============================================================
  prepare-release:
    name: 📦 Prepare Release
    needs: build-test
    runs-on: macos-14
    if: github.head_ref == 'main'
    outputs:
      new_version: ${{ steps.versioning.outputs.new_version }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }} # PAT 토큰 사용
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Request CodeRabbit Summary
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "@coderabbitai review"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for CodeRabbit Summary
        id: detect_summary
        timeout-minutes: 10
        run: |
          for i in {1..120}; do
            echo "[$i/120] Waiting for CodeRabbit summary..."
            PR_BODY=$(gh pr view ${{ github.event.pull_request.number }} --json body --jq .body)
            if [[ "$PR_BODY" == *"Summary by CodeRabbit"* ]]; then
              echo "✅ Summary found!"
              echo "$PR_BODY" > summary_section.html
              echo "summary_found=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "⚠️ Timed out waiting for summary."
          echo "summary_found=false" >> $GITHUB_OUTPUT
          exit 1
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Grant execute permission to scripts
        run: |
          chmod +x .github/scripts/rn_version_manager.sh
          chmod +x .github/scripts/changelog_manager.py

      - name: Increment version and sync native files
        id: versioning
        run: |
          NEW_VERSION=$(./.github/scripts/rn_version_manager.sh increment)
          ./.github/scripts/rn_version_manager.sh sync
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update Changelog
        run: |
          python3 .github/scripts/changelog_manager.py update-from-summary
          python3 .github/scripts/changelog_manager.py generate-md
        env:
          VERSION: ${{ steps.versioning.outputs.new_version }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          TIMESTAMP: ${{ github.event.pull_request.updated_at }}

      - name: Commit and push version updates
        run: |
          git add package.json ios/Wit/Info.plist android/app/build.gradle CHANGELOG.json CHANGELOG.md
          if ! git diff --staged --quiet; then
            git commit -m "chore: bump version to v${{ steps.versioning.outputs.new_version }} [skip ci]"
            git push origin main
          else
            echo "No version changes to commit."
          fi

      # PR 병합은 모든 작업이 성공한 후에 수행됩니다 (update-readme job에서)

      - name: Create and push Git tag
        run: |
          git tag "v${{ steps.versioning.outputs.new_version }}"
          git push origin "v${{ steps.versioning.outputs.new_version }}"

      - name: Save Release Notes for deployment
        id: release_notes
        run: |
          # CHANGELOG.md에서 최신 릴리즈 부분만 추출
          awk '/## v${{ steps.versioning.outputs.new_version }}/{flag=1; next}/## v/{flag=0}flag' CHANGELOG.md > release_notes.txt
          cat release_notes.txt

      - name: Upload Release Notes artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes.txt

  # ===============================================================
  # Job 3: Deploy to TestFlight
  # 앱을 빌드하고 TestFlight에 배포합니다.
  # ===============================================================
  deploy-testflight:
    name: 🚀 Deploy to TestFlight
    needs: prepare-release
    runs-on: macos-14
    steps:
      - name: Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: release

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install JS dependencies
        run: npm ci

      - name: Select Xcode 16
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'

      - name: Install CocoaPods
        run: |
          gem install cocoapods -N
          cd ios && pod install --repo-update

      - name: Import Code-Signing Certificates
        uses: Apple-Actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          keychain-password: ''

      - name: Install Provisioning Profile
        env:
          PROVISIONING_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_BASE64 }}
        run: |
          echo "📱 프로비저닝 프로파일 설치 시작..."
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "✅ 프로비저닝 프로파일 디렉토리 생성 완료"

          echo "🔍 Base64 프로파일 디코딩 중..."
          echo "$PROVISIONING_PROFILE_BASE64" | base64 --decode > profile.mobileprovision
          echo "✅ 프로파일 디코딩 완료"

          echo "📋 프로파일 정보 추출 중..."
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< $(security cms -D -i profile.mobileprovision))
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<< $(security cms -D -i profile.mobileprovision))

          echo "📋 프로파일 정보:"
          echo "  - UUID: $PROFILE_UUID"
          echo "  - Name: $PROFILE_NAME"

          # CLI 프로젝트용 프로파일인지 확인
          if [[ "$PROFILE_NAME" == *"expo"* ]]; then
            echo "❌ 에러: Expo 프로파일이 감지되었습니다!"
            echo "현재 프로파일: $PROFILE_NAME"
            echo ""
            echo "해결 방법:"
            echo "1. Apple Developer Console에서 CLI 프로젝트용 Distribution 프로파일 생성"
            echo "2. 해당 프로파일을 Base64로 인코딩"
            echo "3. GitHub Secrets의 APPLE_PROVISIONING_PROFILE_BASE64 업데이트"
            echo ""
            echo "CLI 프로젝트에는 Expo 프로파일을 사용할 수 없습니다."
            exit 1
          fi

          echo "📂 프로파일 설치 중..."
          cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/"$PROFILE_UUID".mobileprovision
          echo "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_NAME" >> $GITHUB_ENV

          echo "✅ 프로비저닝 프로파일 설치 완료!"
          echo "🔍 설치된 프로파일 확인:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/

      - name: Get Version Info
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          BUILD_NUMBER=$(git rev-list --count HEAD)
          echo "version_name=$VERSION" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT

      - name: Debug Keychain and Environment
        run: |
          echo "🔍 환경 디버깅 시작..."
          echo "Runner temp directory: ${{ runner.temp }}"
          echo "임시 디렉토리 내용:"
          ls -la ${{ runner.temp }}/
          echo ""
          echo "현재 키체인 목록:"
          security list-keychains -d user
          echo ""
          echo "기본 키체인:"
          security default-keychain
          echo ""

      - name: Build and Archive iOS
        run: |
          echo "🏗️ iOS 아카이브 빌드 시작..."

          # 실제 생성된 키체인 찾기
          echo "🔍 생성된 키체인 찾는 중..."
          security list-keychains -d user

          # Apple-Actions가 생성한 키체인 경로 찾기 (로그에서 확인된 경로 사용)
          KEYCHAIN_PATH="/Users/runner/Library/Keychains/signing_temp.keychain-db"

          if [ ! -f "$KEYCHAIN_PATH" ]; then
            echo "❌ signing_temp 키체인이 존재하지 않습니다!"
            echo "사용 가능한 키체인 목록:"
            security list-keychains -d user
            
            # 다른 가능한 키체인 찾기
            ALTERNATIVE_KEYCHAIN=$(security list-keychains -d user | grep -v "login.keychain" | head -1 | tr -d '"' | xargs)
            if [ -n "$ALTERNATIVE_KEYCHAIN" ] && [ -f "$ALTERNATIVE_KEYCHAIN" ]; then
              KEYCHAIN_PATH="$ALTERNATIVE_KEYCHAIN"
              echo "✅ 대안 키체인 사용: $KEYCHAIN_PATH"
            else
              echo "❌ 사용 가능한 키체인을 찾을 수 없습니다"
              exit 1
            fi
          fi

          echo "✅ 키체인 파일 확인됨: $KEYCHAIN_PATH"

          # 키체인 설정
          echo "🔐 키체인 설정 중..."
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "" "$KEYCHAIN_PATH"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"

          echo "✅ 키체인 설정 완료"

          # 코드 사이닝 ID 확인
          echo "🔍 코드 사이닝 ID 확인 중..."
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          echo "📱 프로비저닝 프로파일: ${{ env.PROVISIONING_PROFILE_SPECIFIER }}"
          echo "📦 버전: ${{ steps.version.outputs.version_name }}"
          echo "🔢 빌드 번호: ${{ steps.version.outputs.build_number }}"

          echo "🚀 xcodebuild 아카이브 시작..."
          xcodebuild \
            -workspace ios/Wit.xcworkspace \
            -scheme Wit \
            -configuration Release \
            -archivePath build/Wit.xcarchive \
            -allowProvisioningUpdates \
            clean archive \
            CURRENT_PROJECT_VERSION=${{ steps.version.outputs.build_number }} \
            MARKETING_VERSION=${{ steps.version.outputs.version_name }} \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE_SPECIFIER="${{ env.PROVISIONING_PROFILE_SPECIFIER }}"

          echo "✅ 아카이브 빌드 완료!"

      - name: Export IPA
        run: |
          echo "📦 IPA 내보내기 시작..."
          echo "아카이브 경로: build/Wit.xcarchive"
          echo "내보내기 경로: build/ipa"

          # 아카이브 파일 존재 확인
          if [ ! -d "build/Wit.xcarchive" ]; then
            echo "❌ 아카이브 파일이 존재하지 않습니다!"
            echo "build 디렉토리 내용:"
            ls -la build/ || echo "build 디렉토리가 존재하지 않습니다"
            exit 1
          fi

          echo "✅ 아카이브 파일 확인됨"

          # 환경 변수 확인
          echo "🔍 현재 환경 변수 확인:"
          echo "  - PROVISIONING_PROFILE_SPECIFIER: ${{ env.PROVISIONING_PROFILE_SPECIFIER }}"
          echo "  - 버전: ${{ steps.version.outputs.version_name }}"
          echo "  - 빌드 번호: ${{ steps.version.outputs.build_number }}"

                    # 동적 exportOptions.plist 생성
          echo "📝 동적 Export Options 생성 중..."
          echo "사용할 프로비저닝 프로파일: ${{ env.PROVISIONING_PROFILE_SPECIFIER }}"

          # 키체인에서 실제 인증서 이름 확인
          echo "🔍 설치된 인증서 확인 중..."
          KEYCHAIN_PATH="/Users/runner/Library/Keychains/signing_temp.keychain-db"
          if [ ! -f "$KEYCHAIN_PATH" ]; then
            KEYCHAIN_PATH=$(security list-keychains -d user | grep -v "login.keychain" | head -1 | tr -d '"' | xargs)
          fi

          # 인증서 목록에서 Distribution 인증서 찾기
          CERT_LIST=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" 2>/dev/null || true)
          echo "인증서 목록:"
          echo "$CERT_LIST"

          # Distribution 인증서 이름 추출 (Apple Distribution 또는 iOS Distribution)
          if echo "$CERT_LIST" | grep -q "Apple Distribution"; then
            CERT_NAME="Apple Distribution"
          elif echo "$CERT_LIST" | grep -q "iOS Distribution"; then
            CERT_NAME="iOS Distribution"  
          else
            echo "❌ Distribution 인증서를 찾을 수 없습니다!"
            echo "사용 가능한 인증서:"
            echo "$CERT_LIST"
            exit 1
          fi

          echo "✅ 사용할 인증서: $CERT_NAME"

          # exportOptions.plist 동적 생성 (기존 파일 복사 후 수정)
          PROFILE_NAME="${{ env.PROVISIONING_PROFILE_SPECIFIER }}"
          echo "사용할 프로파일: $PROFILE_NAME"

                    # 기존 파일을 복사
          cp ios/exportOptions.plist ios/exportOptions-runtime.plist

          # 환경 변수 설정
          export PROFILE_NAME="$PROFILE_NAME"
          export CERT_NAME="$CERT_NAME"

                              # 안전한 문자열 교체 (줄바꿈 완전 제거)
          echo "프로파일 교체 중..."

          # 줄바꿈과 공백 완전 제거
          CLEAN_PROFILE_NAME=$(echo "$PROFILE_NAME" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          CLEAN_CERT_NAME=$(echo "$CERT_NAME" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

          echo "정리된 프로파일 이름: [$CLEAN_PROFILE_NAME]"
          echo "정리된 인증서 이름: [$CLEAN_CERT_NAME]"

          # 임시 파일에 정리된 이름 저장
          printf '%s' "$CLEAN_PROFILE_NAME" > /tmp/clean_profile.txt
          printf '%s' "$CLEAN_CERT_NAME" > /tmp/clean_cert.txt

          # sed를 사용한 안전한 교체 (구분자 변경으로 특수문자 처리)
          sed -i '' "s|PLACEHOLDER_PROFILE_NAME|$(cat /tmp/clean_profile.txt)|g" ios/exportOptions-runtime.plist
          sed -i '' "s|Apple Distribution|$(cat /tmp/clean_cert.txt)|g" ios/exportOptions-runtime.plist

          # 임시 파일 정리
          rm -f /tmp/clean_profile.txt /tmp/clean_cert.txt

          echo "✅ 프로파일 교체 완료: [$CLEAN_PROFILE_NAME]"
          echo "✅ 인증서 교체 완료: [$CLEAN_CERT_NAME]"

          echo "✅ Export Options 생성 완료"
          echo "생성된 Export Options 내용:"
          cat ios/exportOptions-runtime.plist

          echo ""
          echo "🔍 최종 검증:"
          # XML에서 실제 값 추출하여 검증
          PLIST_PROFILE=$(grep -A1 "com.Juhkang.Wit" ios/exportOptions-runtime.plist | grep "<string>" | sed 's/<[^>]*>//g' | tr -d ' \t\n\r')
          PLIST_CERT=$(grep -A1 "signingCertificate" ios/exportOptions-runtime.plist | grep "<string>" | sed 's/<[^>]*>//g' | tr -d ' \t\n\r')

          echo "추출된 프로파일: [$PLIST_PROFILE]"
          echo "추출된 인증서: [$PLIST_CERT]"

          # 줄바꿈 문자 확인
          if echo "$PLIST_PROFILE" | grep -q $'\n'; then
            echo "❌ 경고: 프로파일 이름에 줄바꿈이 포함되어 있습니다!"
          fi

          if echo "$PLIST_CERT" | grep -q $'\n'; then
            echo "❌ 경고: 인증서 이름에 줄바꿈이 포함되어 있습니다!"
          fi

          echo "🚀 xcodebuild -exportArchive 시작..."
          xcodebuild -exportArchive \
            -archivePath build/Wit.xcarchive \
            -exportPath build/ipa \
            -exportOptionsPlist ios/exportOptions-runtime.plist

          echo "✅ IPA 내보내기 완료!"
          echo "생성된 IPA 파일:"
          ls -la build/ipa/

      - name: Download Release Notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: .

      - name: Read changelog file for TestFlight
        id: read_changelog
        run: |
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat release_notes.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Verify IPA before Upload
        run: |
          echo "🔍 TestFlight 업로드 전 IPA 파일 확인..."
          IPA_PATH="build/ipa/Wit.ipa"

          if [ ! -f "$IPA_PATH" ]; then
            echo "❌ IPA 파일이 존재하지 않습니다: $IPA_PATH"
            echo "build/ipa 디렉토리 내용:"
            ls -la build/ipa/ || echo "build/ipa 디렉토리가 존재하지 않습니다"
            exit 1
          fi

          echo "✅ IPA 파일 확인됨: $IPA_PATH"
          echo "파일 크기: $(du -h "$IPA_PATH" | cut -f1)"

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v2
        with:
          api-key-id: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          api-issuer-id: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          api-key-content: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
          app-path: 'build/ipa/Wit.ipa'
          changelog: ${{ steps.read_changelog.outputs.changelog }}

      - name: TestFlight Upload Complete
        run: |
          echo "✅ TestFlight 업로드 완료!"
          echo "앱이 TestFlight에 성공적으로 업로드되었습니다."

  # ===============================================================
  # Job 4: Update README
  # 배포 완료 후 main 브랜치의 README 파일을 업데이트합니다.
  # ===============================================================
  update-readme:
    name: 📝 Update README
    needs: deploy-testflight
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get latest version
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "latest_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update README.md
        run: |
          TIMESTAMP=$(date +'%Y-%m-%d')
          VERSION_TEXT="v${{ steps.version.outputs.latest_version }} ($TIMESTAMP)"
          # README에서 버전 라인을 찾아 업데이트 (다양한 형식 지원)
          sed -i -E "s/^(##\\s*(최신|Current|Recent|Latest)?\\s*버전\\s*:\\s*).*/\\1${VERSION_TEXT}/i" README.md

      - name: Commit and push README update
        run: |
          git add README.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: update README with version v${{ steps.version.outputs.latest_version }} [skip ci]"
            git push origin main
          else
            echo "No README changes to commit."
          fi

      - name: Merge PR to release branch
        run: |
          echo "🎉 모든 작업이 성공했습니다. PR을 병합합니다."
          gh pr merge ${{ github.event.pull_request.number }} --squash --admin
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
