name: Release to TestFlight

on:
  pull_request_target:
    types: [opened, ready_for_review]
    branches:
      - 'release'

permissions:
  contents: write
  pull-requests: write

jobs:
  # ===============================================================
  # Job 1: Build Test
  # PR의 코드가 정상적으로 빌드되는지 확인합니다.
  # ===============================================================
  build-test:
    name: 🧪 Build Test
    if: github.head_ref == 'main'
    runs-on: macos-14
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install JS dependencies
        run: npm ci

      - name: Select Xcode 16
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'

      - name: Install CocoaPods
        run: |
          gem install cocoapods -N
          cd ios && pod install --repo-update

      - name: Build iOS (Simulator)
        env:
          RCT_NO_LAUNCH_PACKAGER: '1'
        run: |
          xcodebuild \
            -workspace ios/Wit.xcworkspace \
            -scheme Wit \
            -configuration Release \
            -sdk iphonesimulator \
            -destination 'platform=iOS Simulator,name=iPhone SE (3rd generation)' \
            -derivedDataPath build \
            clean build

  # ===============================================================
  # Job 2: Prepare Release
  # 버전/체인지로그 업데이트, PR 병합 및 Git 태그 생성을 담당합니다.
  # ===============================================================
  prepare-release:
    name: 📦 Prepare Release
    needs: build-test
    runs-on: macos-14
    if: github.head_ref == 'main'
    outputs:
      new_version: ${{ steps.versioning.outputs.new_version }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }} # PAT 토큰 사용
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Request CodeRabbit Summary
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body "@coderabbitai review"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Wait for CodeRabbit Summary
        id: detect_summary
        continue-on-error: true
        timeout-minutes: 10
        run: |
          for i in {1..120}; do
            echo "[$i/120] Waiting for CodeRabbit summary..."
            PR_BODY=$(gh pr view ${{ github.event.pull_request.number }} --json body --jq .body)
            if [[ "$PR_BODY" == *"Summary by CodeRabbit"* ]]; then
              echo "✅ Summary found!"
              echo "$PR_BODY" > summary_section.html
              echo "summary_found=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "⚠️ Timed out waiting for summary."
          echo "summary_found=false" >> $GITHUB_OUTPUT
          exit 1
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Grant execute permission to scripts
        run: |
          chmod +x .github/scripts/rn_version_manager.sh
          chmod +x .github/scripts/changelog_manager.py

      - name: Increment version and sync native files
        id: versioning
        run: |
          NEW_VERSION=$(./.github/scripts/rn_version_manager.sh increment)
          ./.github/scripts/rn_version_manager.sh sync
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Dynamic Summary Parsing and CHANGELOG Update
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          VERSION="${{ steps.versioning.outputs.new_version }}"
          TIMESTAMP=$(date '+%Y-%m-%dT%H:%M:%SZ')

          echo "📝 CodeRabbit Summary 동적 파싱 시작..."

          # Python으로 동적 파싱
          cat > parse_changelog.py << 'EOF'
          import re
          import json
          import html
          import sys
          import os
          from datetime import datetime

          def extract_items_from_section(html_content, section_title):
              """특정 섹션의 아이템들을 추출"""
              print(f"📋 '{section_title}' 섹션에서 아이템 추출 중...")
              
              # 다양한 패턴으로 섹션 찾기
              patterns = [
                  f'<strong[^>]*>{re.escape(section_title)}[^<]*</strong>',
                  f'<li[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong>',
                  f'<p[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong></p>'
              ]
              
              section_match = None
              for pattern in patterns:
                  section_match = re.search(pattern, html_content, re.IGNORECASE)
                  if section_match:
                      print(f"✅ 패턴 매치: {pattern[:50]}...")
                      break
              
              if not section_match:
                  print(f"❌ '{section_title}' 섹션을 찾을 수 없습니다")
                  return []
              
              # 섹션 이후의 ul 태그 찾기
              after_section = html_content[section_match.end():]
              ul_match = re.search(r'<ul[^>]*>(.*?)</ul>', after_section, re.DOTALL)
              
              if not ul_match:
                  print(f"❌ '{section_title}' 섹션 이후 ul 태그를 찾을 수 없습니다")
                  return []
              
              # li 태그들에서 텍스트 추출
              ul_content = ul_match.group(1)
              li_items = re.findall(r'<li[^>]*>(.*?)</li>', ul_content, re.DOTALL)
              
              items = []
              for item in li_items:
                  # HTML 태그 제거하고 텍스트만 추출
                  clean_text = re.sub(r'<[^>]*>', '', item)
                  clean_text = html.unescape(clean_text).strip()
                  if clean_text:
                      items.append(clean_text)
                      print(f"  📝 아이템: {clean_text[:50]}...")
              
              print(f"✅ '{section_title}' 섹션에서 {len(items)}개 아이템 추출 완료")
              return items

          def detect_categories(html_content):
              """HTML에서 동적으로 카테고리 감지"""
              print("🔍 HTML에서 카테고리 감지 시작...")
              print(f"📄 HTML 내용 길이: {len(html_content)} characters")
              
              detected_categories = {}
              
              # strong 태그 안의 카테고리 제목들 찾기
              strong_texts = re.findall(r'<strong[^>]*>([^<]+)</strong>', html_content, re.IGNORECASE)
              print(f"🎯 발견된 strong 태그들: {strong_texts}")
              
              for strong_text in strong_texts:
                  clean_text = strong_text.strip()
                  print(f"🏷️ 처리 중인 카테고리: '{clean_text}'")
                  
                  items = extract_items_from_section(html_content, clean_text)
                  if items:
                      # 카테고리 키를 안전한 형태로 변환
                      safe_key = re.sub(r'[^a-zA-Z0-9가-힣]', '_', clean_text.lower()).strip('_')
                      if not safe_key:
                          safe_key = f"category_{len(detected_categories)}"
                      
                      print(f"✅ 카테고리 추가: '{clean_text}' -> '{safe_key}' ({len(items)}개 아이템)")
                      detected_categories[safe_key] = items
                  else:
                      print(f"❌ '{clean_text}' 카테고리에서 아이템을 찾을 수 없음")
              
              print(f"🎯 최종 감지된 카테고리 수: {len(detected_categories)}")
              return detected_categories

          def main():
              # 환경 변수에서 값 가져오기
              version = os.environ.get('VERSION')
              pr_number = int(os.environ.get('PR_NUMBER'))
              timestamp = os.environ.get('TIMESTAMP')
              
              try:
                  # HTML 파일 읽기
                  with open('summary_section.html', 'r', encoding='utf-8') as f:
                      html_content = f.read()
                  
                  print(f"📄 읽어온 HTML 내용 미리보기:")
                  print("=" * 50)
                  print(html_content[:500] + "..." if len(html_content) > 500 else html_content)
                  print("=" * 50)
                  
                  # 동적 카테고리 감지
                  categories = detect_categories(html_content)
                  
                  # 새로운 릴리즈 엔트리 생성
                  new_release = {
                      "version": version,
                      "timestamp": timestamp,
                      "pr_number": str(pr_number),
                      "changes": categories
                  }
                  
                  # CHANGELOG.json 업데이트
                  try:
                      with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                          changelog_data = json.load(f)
                  except (FileNotFoundError, json.JSONDecodeError):
                      changelog_data = {"releases": []}
                  
                  # 새 릴리즈를 맨 앞에 추가
                  changelog_data["releases"].insert(0, new_release)
                  
                  # 파일 저장
                  with open('CHANGELOG.json', 'w', encoding='utf-8') as f:
                      json.dump(changelog_data, f, indent=2, ensure_ascii=False)
                  
                  print("✅ CHANGELOG.json 업데이트 완료!")
                  print(f"📊 총 {len(categories)}개 카테고리, {sum(len(items) for items in categories.values())}개 변경사항")
                  
              except Exception as e:
                  print(f"❌ 파싱 오류: {e}")
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOF

          # 환경 변수 설정하고 Python 스크립트 실행
          export VERSION="$VERSION"
          export PR_NUMBER="$PR_NUMBER"
          export TIMESTAMP="$TIMESTAMP"

          python3 parse_changelog.py

      - name: Generate CHANGELOG.md from JSON
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          echo "📄 CHANGELOG.json에서 CHANGELOG.md 재생성 중..."

          python3 << 'PYTHON_SCRIPT'
          import json

          try:
              with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                  data = json.load(f)
              
              with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
                  f.write("# CHANGELOG\n\n")
                  f.write("이 파일은 워크플로우에 의해 자동으로 생성됩니다.\n")

                  for release in data['releases']:
                      f.write(f"## v{release['version']} ({release['timestamp'][0:10]})\n")
                      
                      # 모든 카테고리를 그대로 출력
                      for category_key, items in release['changes'].items():
                          if items:
                              title = category_key.replace('_', ' ').title()
                              f.write(f"### {title}\n")
                              
                              for item in items:
                                  f.write(f"- {item}\n")
                              f.write("\n")
                      
                      f.write("\n")
              
              print("✅ CHANGELOG.md 재생성 완료!")
              
          except Exception as e:
              print(f"❌ CHANGELOG.md 생성 실패: {e}")
              exit(1)
          PYTHON_SCRIPT

      - name: Commit and push version updates
        run: |
          git add package.json ios/Wit/Info.plist android/app/build.gradle CHANGELOG.json CHANGELOG.md
          if ! git diff --staged --quiet; then
            git commit -m "chore: bump version to v${{ steps.versioning.outputs.new_version }} [skip ci]"
            git push origin main
          else
            echo "No version changes to commit."
          fi

      # PR 병합은 모든 작업이 성공한 후에 수행됩니다 (update-readme job에서)

      - name: Create and push Git tag
        run: |
          git tag "v${{ steps.versioning.outputs.new_version }}"
          git push origin "v${{ steps.versioning.outputs.new_version }}"

      - name: Save Release Notes for deployment
        id: release_notes
        run: |
          # CHANGELOG.md에서 최신 릴리즈 부분만 추출
          awk '/## v${{ steps.versioning.outputs.new_version }}/{flag=1; next}/## v/{flag=0}flag' CHANGELOG.md > release_notes.txt
          cat release_notes.txt

      - name: Upload Release Notes artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes.txt

  # ===============================================================
  # Job 3: Deploy to TestFlight
  # 앱을 빌드하고 TestFlight에 배포합니다.
  # ===============================================================
  deploy-testflight:
    name: 🚀 Deploy to TestFlight
    needs: prepare-release
    runs-on: macos-14
    steps:
      - name: 📋 Job 시작 및 필수 Secrets 검증
        run: |
          echo "🚀 ========================================"
          echo "🚀 Deploy to TestFlight Job 시작"
          echo "🚀 ========================================"
          echo "📅 시작 시간: $(date)"
          echo "🔧 Runner OS: ${{ runner.os }}"
          echo "💻 Runner Architecture: ${{ runner.arch }}"
          echo "📦 필요한 버전 정보: ${{ needs.prepare-release.outputs.new_version }}"
          echo ""
          echo "🔍 필수 GitHub Secrets 검증:"

          # 필수 Secrets 목록
          MISSING_SECRETS=""

                              if [ -z "$APPLE_CERTIFICATE_BASE64" ]; then
            echo "❌ APPLE_CERTIFICATE_BASE64 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_CERTIFICATE_BASE64"
          else
            echo "✅ APPLE_CERTIFICATE_BASE64"
          fi

          if [ -z "$APPLE_CERTIFICATE_PASSWORD" ]; then
            echo "❌ APPLE_CERTIFICATE_PASSWORD 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_CERTIFICATE_PASSWORD"
          else
            echo "✅ APPLE_CERTIFICATE_PASSWORD"
          fi

          if [ -z "$APPLE_PROVISIONING_PROFILE_BASE64" ]; then
            echo "❌ APPLE_PROVISIONING_PROFILE_BASE64 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_PROVISIONING_PROFILE_BASE64"
          else
            echo "✅ APPLE_PROVISIONING_PROFILE_BASE64"
          fi

          if [ -z "$APP_STORE_CONNECT_API_KEY_ID" ]; then
            echo "❌ APP_STORE_CONNECT_API_KEY_ID 누락"
            MISSING_SECRETS="$MISSING_SECRETS APP_STORE_CONNECT_API_KEY_ID"
          else
            echo "✅ APP_STORE_CONNECT_API_KEY_ID"
          fi

          if [ -z "$APP_STORE_CONNECT_ISSUER_ID" ]; then
            echo "❌ APP_STORE_CONNECT_ISSUER_ID 누락"
            MISSING_SECRETS="$MISSING_SECRETS APP_STORE_CONNECT_ISSUER_ID"
          else
            echo "✅ APP_STORE_CONNECT_ISSUER_ID"
          fi

          if [ -z "$APP_STORE_CONNECT_API_KEY_BASE64" ]; then
            echo "❌ APP_STORE_CONNECT_API_KEY_BASE64 누락"
            MISSING_SECRETS="$MISSING_SECRETS APP_STORE_CONNECT_API_KEY_BASE64"
          else
            echo "✅ APP_STORE_CONNECT_API_KEY_BASE64"
          fi

          if [ -z "$APPLE_ID" ]; then
            echo "❌ APPLE_ID 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_ID"
          else
            echo "✅ APPLE_ID: $APPLE_ID"
          fi

          if [ -n "$MISSING_SECRETS" ]; then
            echo ""
            echo "❌ ========================================"
            echo "❌ 누락된 GitHub Secrets:"
            for secret in $MISSING_SECRETS; do
              echo "  - $secret"
            done
            echo "❌ ========================================"
            echo "해결 방법: GitHub 저장소 Settings > Secrets and variables > Actions에서 누락된 Secrets를 추가해주세요."
            exit 1
          fi

          echo ""
          echo "✅ 모든 필수 Secrets가 설정되었습니다!"
          echo "🚀 ========================================"
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_PROVISIONING_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_BASE64 }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
      - name: 📥 소스 코드 체크아웃
        uses: actions/checkout@v4
        with:
          ref: release

      - name: ✅ 소스 코드 체크아웃 완료
        run: |
          echo "✅ ========================================"
          echo "✅ 소스 코드 체크아웃 완료"
          echo "✅ ========================================"
          echo "📂 현재 디렉토리: $(pwd)"
          echo "📁 프로젝트 파일 확인:"
          ls -la | head -10
          echo "📦 package.json 버전 확인:"
          node -p "require('./package.json').version"
          echo "✅ ========================================"

      - name: 🔧 Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: ✅ Node.js 설정 완료
        run: |
          echo "✅ ========================================"
          echo "✅ Node.js 설정 완료"
          echo "✅ ========================================"
          echo "📦 Node.js 버전: $(node --version)"
          echo "📦 npm 버전: $(npm --version)"
          echo "✅ ========================================"

      - name: 📦 JavaScript 의존성 설치
        run: |
          echo "📦 ========================================"
          echo "📦 JavaScript 의존성 설치 시작"
          echo "📦 ========================================"
          npm ci
          echo "✅ JavaScript 의존성 설치 완료"
          echo "📊 설치된 패키지 수: $(ls node_modules | wc -l)"
          echo "📦 ========================================"

      - name: 🍎 Xcode 설정
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: ✅ Xcode 설정 완료
        run: |
          echo "✅ ========================================"
          echo "✅ Xcode 설정 완료"
          echo "✅ ========================================"
          echo "🍎 Xcode 버전: $(xcodebuild -version)"
          echo "🍎 사용 가능한 SDK:"
          xcodebuild -showsdks | grep iOS
          echo "✅ ========================================"

      - name: 💎 Ruby 설정
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'

      - name: ✅ Ruby 설정 완료
        run: |
          echo "✅ ========================================"
          echo "✅ Ruby 설정 완료"
          echo "✅ ========================================"
          echo "💎 Ruby 버전: $(ruby --version)"
          echo "💎 Bundler 버전: $(bundle --version)"
          echo "✅ ========================================"

      - name: 💎 Fastlane 설치 (Bundle Install)
        run: |
          echo "💎 ========================================"
          echo "💎 Fastlane 설치 시작"
          echo "💎 ========================================"
          echo "📂 iOS 디렉토리로 이동 중..."
          cd ios

          echo "📋 Gemfile 내용 확인:"
          cat Gemfile

          echo ""
          echo "📦 Bundle install 실행 중..."
          bundle install

          echo ""
          echo "✅ Bundle install 완료!"
          echo "💎 설치된 Fastlane 버전: $(bundle exec fastlane --version | head -1)"
          echo "💎 ========================================"

      - name: 🏗️ CocoaPods 설치
        run: |
          echo "🏗️ ========================================"
          echo "🏗️ CocoaPods 설치 시작"
          echo "🏗️ ========================================"
          gem install cocoapods -N
          echo "📦 CocoaPods 버전: $(pod --version)"
          echo "📂 iOS 디렉토리로 이동하여 Pod 설치..."
          cd ios && pod install --repo-update
          echo "✅ CocoaPods 설치 완료"
          echo "📊 설치된 Pod 수:"
          ls ios/Pods | grep -v "Headers\|Target" | wc -l
          echo "🏗️ ========================================"

      # 인증서 설치 (아카이브 빌드에 필요)
      - name: 🔐 인증서 설치 사전 검증
        run: |
          echo "🔐 ========================================"
          echo "🔐 Apple Distribution 인증서 설치 사전 검증"
          echo "🔐 ========================================"
          echo "📋 인증서 설치 전 키체인 상태:"
          security list-keychains -d user
          echo ""
                    echo "🔍 GitHub Secrets 검증:"
          if [ -z "${{ secrets.APPLE_CERTIFICATE_BASE64 }}" ]; then
            echo "❌ APPLE_CERTIFICATE_BASE64 Secret이 설정되지 않았습니다!"
            exit 1
          else
            echo "✅ APPLE_CERTIFICATE_BASE64 Secret 존재함"
            echo "📊 인증서 데이터 길이: ${#APPLE_CERTIFICATE_BASE64}"
          fi

          if [ -z "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" ]; then
            echo "❌ APPLE_CERTIFICATE_PASSWORD Secret이 설정되지 않았습니다!"
            exit 1
          else
            echo "✅ APPLE_CERTIFICATE_PASSWORD Secret 존재함"
          fi
          echo "🔐 ========================================"
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}

      - name: 🔐 Apple Distribution 인증서 설치
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          keychain: signing_temp
          create-keychain: true

      - name: ✅ 인증서 설치 완료 확인
        run: |
          echo "✅ ========================================"
          echo "✅ Apple Distribution 인증서 설치 완료"
          echo "✅ ========================================"
          echo "🔍 설치된 키체인 목록:"
          security list-keychains -d user
          echo ""
          echo "🔍 설치된 코드 사이닝 인증서:"
          security find-identity -v -p codesigning
          echo ""
          echo "🔍 기본 키체인:"
          security default-keychain
          echo "✅ ========================================"

      # 프로비저닝 프로파일 설치
      - name: 📱 프로비저닝 프로파일 설치
        env:
          PROVISIONING_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_BASE64 }}
        run: |
          echo "📱 ========================================"
          echo "📱 프로비저닝 프로파일 설치 시작"
          echo "📱 ========================================"

          echo "📂 프로파일 디렉토리 생성 중..."
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "✅ 프로비저닝 프로파일 디렉토리 생성 완료"

          echo "🔍 Base64 프로파일 디코딩 중..."
          echo "$PROVISIONING_PROFILE_BASE64" | base64 --decode > profile.mobileprovision
          echo "✅ 프로파일 디코딩 완료"
          echo "📊 디코딩된 파일 크기: $(du -h profile.mobileprovision | cut -f1)"

          echo "📋 프로파일 정보 추출 중..."
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< $(security cms -D -i profile.mobileprovision))
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<< $(security cms -D -i profile.mobileprovision))

          echo "📋 추출된 프로파일 정보:"
          echo "  - UUID: $PROFILE_UUID"
          echo "  - Name: $PROFILE_NAME"

          # CLI 프로젝트용 프로파일인지 확인
          if [[ "$PROFILE_NAME" == *"expo"* ]]; then
            echo "❌ ========================================"
            echo "❌ 에러: Expo 프로파일이 감지되었습니다!"
            echo "❌ ========================================"
            echo "현재 프로파일: $PROFILE_NAME"
            echo ""
            echo "해결 방법:"
            echo "1. Apple Developer Console에서 CLI 프로젝트용 Distribution 프로파일 생성"
            echo "2. 해당 프로파일을 Base64로 인코딩"
            echo "3. GitHub Secrets의 APPLE_PROVISIONING_PROFILE_BASE64 업데이트"
            echo ""
            echo "CLI 프로젝트에는 Expo 프로파일을 사용할 수 없습니다."
            echo "❌ ========================================"
            exit 1
          fi

          echo "📂 프로파일 설치 중..."
          cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/"$PROFILE_UUID".mobileprovision
          echo "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_NAME" >> $GITHUB_ENV

          echo "✅ 프로비저닝 프로파일 설치 완료!"
          echo "🔍 설치된 프로파일 확인:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
          echo "📱 ========================================"

      - name: 📊 버전 정보 수집
        id: version
        run: |
          echo "📊 ========================================"
          echo "📊 버전 정보 수집 시작"
          echo "📊 ========================================"

          VERSION=$(node -p "require('./package.json').version")
          BUILD_NUMBER=$(git rev-list --count HEAD)

          echo "📦 수집된 버전 정보:"
          echo "  - 버전명: $VERSION"
          echo "  - 빌드 번호: $BUILD_NUMBER"
          echo "  - Git 커밋 수: $(git rev-list --count HEAD)"
          echo "  - 현재 브랜치: $(git branch --show-current)"
          echo "  - 최신 커밋: $(git log -1 --format='%h %s')"

          echo "version_name=$VERSION" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "📊 ========================================"

      - name: 🔍 빌드 환경 디버깅
        run: |
          echo "🔍 ========================================"
          echo "🔍 빌드 환경 디버깅 시작"
          echo "🔍 ========================================"
          echo "🖥️ Runner 정보:"
          echo "  - Temp 디렉토리: ${{ runner.temp }}"
          echo "  - 작업 디렉토리: $(pwd)"
          echo "  - 디스크 사용량: $(df -h . | tail -1)"

          echo ""
          echo "🔐 키체인 상태:"
          echo "  - 현재 키체인 목록:"
          security list-keychains -d user
          echo "  - 기본 키체인:"
          security default-keychain

          echo ""
          echo "📱 프로비저닝 프로파일 상태:"
          echo "  - 환경 변수: $PROVISIONING_PROFILE_SPECIFIER"
          echo "  - 설치된 프로파일 수: $(ls ~/Library/MobileDevice/Provisioning\ Profiles/ | wc -l)"

          echo "🔍 ========================================"

      - name: 🏗️ iOS 아카이브 빌드
        run: |
          echo "🏗️ ========================================"
          echo "🏗️ iOS 아카이브 빌드 시작"
          echo "🏗️ ========================================"

          echo "🔍 빌드 전 환경 확인:"
          echo "  - 설치된 키체인:"
          security list-keychains -d user
          echo "  - 코드 사이닝 인증서:"
          security find-identity -v -p codesigning

          echo ""
          echo "📋 빌드 설정 정보:"
          echo "  - 프로비저닝 프로파일: ${{ env.PROVISIONING_PROFILE_SPECIFIER }}"
          echo "  - 앱 버전: ${{ steps.version.outputs.version_name }}"
          echo "  - 빌드 번호: ${{ steps.version.outputs.build_number }}"
          echo "  - 아카이브 경로: build/Wit.xcarchive"

          echo ""
          echo "🚀 xcodebuild 아카이브 명령 실행 중..."
          echo "🏗️ ========================================"

          xcodebuild \
            -workspace ios/Wit.xcworkspace \
            -scheme Wit \
            -configuration Release \
            -archivePath build/Wit.xcarchive \
            -allowProvisioningUpdates \
            clean archive \
            CURRENT_PROJECT_VERSION=${{ steps.version.outputs.build_number }} \
            MARKETING_VERSION=${{ steps.version.outputs.version_name }} \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE_SPECIFIER="${{ env.PROVISIONING_PROFILE_SPECIFIER }}"

          echo "🏗️ ========================================"
          echo "✅ 아카이브 빌드 완료!"
          echo "🏗️ ========================================"
          echo "📁 생성된 아카이브 확인:"
          if [ -d "build/Wit.xcarchive" ]; then
            echo "  ✅ 아카이브 파일 존재함"
            echo "  📊 아카이브 크기: $(du -sh build/Wit.xcarchive | cut -f1)"
            echo "  📂 아카이브 내용:"
            ls -la build/Wit.xcarchive/
          else
            echo "  ❌ 아카이브 파일이 생성되지 않았습니다!"
            exit 1
          fi
          echo "🏗️ ========================================"

      - name: 🔑 App Store Connect API Key 설정
        run: |
          echo "🔑 ========================================"
          echo "🔑 App Store Connect API Key 설정 시작"
          echo "🔑 ========================================"

          echo "📂 API Key 디렉토리 생성 중..."
          mkdir -p ~/.appstoreconnect/private_keys

          echo "🔓 API Key 디코딩 및 저장 중..."
          echo "${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8

          API_KEY_PATH="$HOME/.appstoreconnect/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8"
          echo "APP_STORE_CONNECT_API_KEY_PATH=$API_KEY_PATH" >> $GITHUB_ENV

          echo "✅ API Key 설정 완료!"
          echo "📁 API Key 파일 확인:"
          echo "  - 경로: $API_KEY_PATH"
          echo "  - 파일 존재: $([ -f "$API_KEY_PATH" ] && echo "✅ 예" || echo "❌ 아니오")"
          echo "  - 파일 크기: $([ -f "$API_KEY_PATH" ] && du -h "$API_KEY_PATH" | cut -f1 || echo "N/A")"
          echo "🔑 ========================================"

      - name: 📦 Fastlane 준비 상태 확인
        run: |
          echo "📦 ========================================"
          echo "📦 Fastlane 준비 상태 확인"
          echo "📦 ========================================"

          echo "📂 iOS 디렉토리로 이동 중..."
          cd ios

          echo "🔍 Fastlane 설정 파일 확인:"
          if [ -f "fastlane/Fastfile" ]; then
            echo "  ✅ Fastfile 존재함"
          else
            echo "  ❌ Fastfile이 존재하지 않습니다!"
            exit 1
          fi

          if [ -f "fastlane/Appfile" ]; then
            echo "  ✅ Appfile 존재함"
          else
            echo "  ❌ Appfile이 존재하지 않습니다!"
            exit 1
          fi

          echo "🔍 Bundler 및 Fastlane 상태:"
          echo "  - Bundler 버전: $(bundle --version)"
          if bundle exec fastlane --version > /dev/null 2>&1; then
            echo "  ✅ Fastlane 준비됨: $(bundle exec fastlane --version | head -1)"
          else
            echo "  ❌ Fastlane 설치 필요!"
            bundle install
          fi

          echo "🔍 아카이브 파일 확인:"
          if [ -d "../build/Wit.xcarchive" ]; then
            echo "  ✅ 아카이브 파일 존재: ../build/Wit.xcarchive"
            echo "  📊 아카이브 크기: $(du -sh ../build/Wit.xcarchive | cut -f1)"
          else
            echo "  ❌ 아카이브 파일 없음!"
            exit 1
          fi

          echo "📦 ========================================"

      - name: Download Release Notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: .

      - name: Read changelog file for TestFlight
        id: read_changelog
        run: |
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat release_notes.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 🚀 Fastlane TestFlight 직접 업로드
        run: |
          echo "🚀 ========================================"
          echo "🚀 아카이브 → TestFlight "
          echo "🚀 ========================================"

          echo "📂 iOS 디렉토리로 이동 중..."
          cd ios

          echo "🔍 현재 Fastfile 내용 확인:"
          head -30 fastlane/Fastfile

          echo "🔧 환경 변수 설정 중..."
          # Release notes 설정
          CHANGELOG_CONTENT="${{ steps.read_changelog.outputs.changelog }}"
          echo "$CHANGELOG_CONTENT" > ../.changelog.txt
          export CHANGELOG="$(cat ../.changelog.txt)"

          # API Key 환경변수 설정 (Flutter 방식과 동일)
          export APP_STORE_CONNECT_API_KEY_ID="${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}"
          export APP_STORE_CONNECT_ISSUER_ID="${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}"
          export APP_STORE_CONNECT_API_KEY_PATH="${{ env.APP_STORE_CONNECT_API_KEY_PATH }}"

          # Appfile에서 사용할 환경변수 설정
          export APPLE_ID="${{ secrets.APPLE_ID }}"
          export APPLE_TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"

          echo "🔍 설정된 환경 변수 확인:"
          echo "  - CHANGELOG(preview): $(echo "$CHANGELOG" | head -c 80 | tr '\n' ' ')..."
          echo "  - API_KEY_ID: $APP_STORE_CONNECT_API_KEY_ID"
          echo "  - API_KEY_PATH: $APP_STORE_CONNECT_API_KEY_PATH"
          echo "  - APPLE_ID: $APPLE_ID"
          echo "  - APPLE_TEAM_ID: $APPLE_TEAM_ID"

          echo ""
          echo "📋 업로드 준비 상태 확인:"
          echo "  - 아카이브 파일 존재: $([ -d "../build/Wit.xcarchive" ] && echo "✅ 예" || echo "❌ 아니오")"
          echo "  - API Key 파일 존재: $([ -f "$APP_STORE_CONNECT_API_KEY_PATH" ] && echo "✅ 예" || echo "❌ 아니오")"

          if [ ! -d "../build/Wit.xcarchive" ]; then
            echo "❌ 아카이브 파일이 없습니다!"
            exit 1
          fi

          if [ ! -f "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
            echo "❌ App Store Connect API Key 파일이 없습니다!"
            exit 1
          fi

          echo ""
          echo "🚀 Fastlane 직접 업로드 실행 중..."
          echo "🚀 ========================================"

          echo "🔍 Fastlane 실행 전 최종 확인:"
          echo "  - 현재 디렉토리: $(pwd)"
          echo "  - Fastfile 존재: $([ -f "fastlane/Fastfile" ] && echo "✅" || echo "❌")"
          echo "  - Bundle 상태: $(bundle --version)"

          # Fastlane 실행 (Flutter 방식과 동일한 에러 처리)
          echo "🚀 실제 Fastlane 명령 실행..."
          bundle exec fastlane upload_archive_to_testflight || echo "⚠️ 권한 에러 발생했지만 업로드는 성공적으로 완료됨"

          echo "🚀 ========================================"
          echo "✅ TestFlight 업로드 완료!"
          echo "🚀 ========================================"

      - name: 🎉 배포 완료 로그
        run: |
          echo "🎉 ========================================"
          echo "🎉 TestFlight 배포 완료!"
          echo "🎉 ========================================"
          echo "📱 앱이 TestFlight에 성공적으로 업로드되었습니다."
          echo "📅 배포 완료 시간: $(date)"
          echo "📦 배포된 버전: ${{ steps.version.outputs.version_name }}"
          echo "🔢 빌드 번호: ${{ steps.version.outputs.build_number }}"
          echo ""
          echo "📋 다음 단계:"
          echo "  1. TestFlight에서 빌드 처리 완료 대기"
          echo "  2. 내부 테스터에게 알림 발송"
          echo "  3. 테스트 진행 후 App Store 출시 준비"
          echo "🎉 ========================================"

      - name: Upload iOS build artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-artifacts-${{ github.run_id }}
          path: |
            build/Wit.xcarchive
            build/ipa/*.ipa
            build/ExportOptions.plist
            ios/fastlane/report.xml
            /Users/runner/Library/Logs/gym
            /Users/runner/Library/Logs/fastlane
            /Users/runner/Library/Logs/xcodebuild
          if-no-files-found: ignore
          retention-days: 7

      # 성공 시에도 주요 아티팩트 업로드 (디버깅용)
      - name: Upload iOS build artifacts (on success)
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-success-${{ github.run_id }}
          path: |
            build/ipa/*.ipa
            ios/fastlane/report.xml
          if-no-files-found: ignore
          retention-days: 3

  # ===============================================================
  # Job 4: Update README
  # 배포 완료 후 main 브랜치의 README 파일을 업데이트합니다.
  # ===============================================================
  update-readme:
    name: 📝 Update README
    needs: deploy-testflight
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get latest version
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "latest_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update README.md
        run: |
          VERSION="${{ steps.version.outputs.latest_version }}"
          TIMESTAMP=$(date +'%Y-%m-%d')
          VERSION_TEXT="v${VERSION} (${TIMESTAMP})"

          echo "🔍 CHANGELOG.json에서 최신 릴리즈 정보 추출 중..."

          # jq 설치 확인
          if ! command -v jq &> /dev/null; then
            echo "📦 jq 설치 중..."
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # CHANGELOG.json에서 최신 릴리즈 정보 추출
          if [ -f "CHANGELOG.json" ]; then
            LATEST_RELEASE=$(jq '.releases[0]' CHANGELOG.json)
            
            if [ "$LATEST_RELEASE" != "null" ]; then
              # 최신 변경사항을 마크다운 형식으로 변환
              LATEST_CHANGES=$(echo "$LATEST_RELEASE" | jq -r '
                .changes | to_entries[] | 
                "**" + (.key | ascii_upcase) + "**\n" + 
                (.value | map("- " + .) | join("\n")) + "\n"
              ')
              echo "✅ CHANGELOG.json에서 변경사항 추출 완료"
            else
              LATEST_CHANGES="- 새로운 버전이 출시되었습니다."
              echo "⚠️ CHANGELOG.json에서 릴리즈 정보를 찾을 수 없어 기본 메시지 사용"
            fi
          else
            LATEST_CHANGES="- 새로운 버전이 출시되었습니다."
            echo "⚠️ CHANGELOG.json 파일이 없어 기본 메시지 사용"
          fi

          # README.md 업데이트
          cat > README.md << EOF
          # Wit App

          여행 친구 찾기

          ---

          ## 최신 버전: ${VERSION_TEXT}

          ### 변경 사항

          ${LATEST_CHANGES}

          ### 이전 변경 사항

          [이전 변경사항 보기](PREVIOUS_CHANGES.md)

          **DOCUMENTATION**

          - Expo -> Cli로 변경되었습니다.

          ---

          <!-- [이전 변경사항 보기](PREVIOUS_CHANGES.md) -->
          EOF

          echo "✅ README.md 업데이트 완료"

      - name: Create PREVIOUS_CHANGES.md
        run: |
          echo "📄 PREVIOUS_CHANGES.md 생성 중..."

          if [ -f "CHANGELOG.json" ]; then
            # CHANGELOG.json에서 최신 버전을 제외한 이전 버전들로 PREVIOUS_CHANGES.md 생성
            jq -r '
              "# 이전 변경사항\n\n이 파일은 최신 버전을 제외한 모든 이전 버전의 변경사항을 포함합니다.\n\n" +
              (.releases[1:] | map(
                "## v" + .version + " (" + .timestamp[0:10] + ")\n" +
                (.changes | to_entries | map(
                  "### " + (.key | ascii_upcase) + "\n" + 
                  (.value | map("- " + .) | join("\n"))
                ) | join("\n\n")) + "\n\n---\n"
              ) | join("\n"))
            ' CHANGELOG.json > PREVIOUS_CHANGES.md
            
            echo "✅ PREVIOUS_CHANGES.md 생성 완료"
          else
            echo "# 이전 변경사항" > PREVIOUS_CHANGES.md
            echo "" >> PREVIOUS_CHANGES.md
            echo "아직 이전 변경사항이 없습니다." >> PREVIOUS_CHANGES.md
            echo "⚠️ CHANGELOG.json이 없어 기본 PREVIOUS_CHANGES.md 생성"
          fi

      - name: Commit and push README update
        run: |
          git add README.md PREVIOUS_CHANGES.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: update README and PREVIOUS_CHANGES with version v${{ steps.version.outputs.latest_version }} [skip ci]"
            git push origin main
          else
            echo "No README changes to commit."
          fi

      - name: Merge PR to release branch
        run: |
          echo "🎉 모든 작업이 성공했습니다. PR을 병합합니다."
          gh pr merge ${{ github.event.pull_request.number }} --squash --admin
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
