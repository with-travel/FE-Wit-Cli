name: 🚀 Deploy to TestFlight

on:
  workflow_run:
    workflows: ['📝 CHANGELOG Update']
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  deploy-testflight:
    name: 🚀 Deploy to TestFlight
    runs-on: macos-14
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: 📋 Job 시작 및 필수 Secrets 검증
        run: |
          echo "🚀 ========================================"
          echo "🚀 Deploy to TestFlight Job 시작"
          echo "🚀 ========================================"
          echo "📅 시작 시간: $(date)"
          echo "🔧 Runner OS: ${{ runner.os }}"
          echo "💻 Runner Architecture: ${{ runner.arch }}"
          echo ""
          echo "🔍 필수 GitHub Secrets 검증:"

          # 필수 Secrets 목록
          MISSING_SECRETS=""

          if [ -z "$APPLE_CERTIFICATE_BASE64" ]; then
            echo "❌ APPLE_CERTIFICATE_BASE64 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_CERTIFICATE_BASE64"
          else
            echo "✅ APPLE_CERTIFICATE_BASE64"
          fi

          if [ -z "$APPLE_CERTIFICATE_PASSWORD" ]; then
            echo "❌ APPLE_CERTIFICATE_PASSWORD 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_CERTIFICATE_PASSWORD"
          else
            echo "✅ APPLE_CERTIFICATE_PASSWORD"
          fi

          if [ -z "$APPLE_PROVISIONING_PROFILE_BASE64" ]; then
            echo "❌ APPLE_PROVISIONING_PROFILE_BASE64 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_PROVISIONING_PROFILE_BASE64"
          else
            echo "✅ APPLE_PROVISIONING_PROFILE_BASE64"
          fi

          if [ -z "$APP_STORE_CONNECT_API_KEY_ID" ]; then
            echo "❌ APP_STORE_CONNECT_API_KEY_ID 누락"
            MISSING_SECRETS="$MISSING_SECRETS APP_STORE_CONNECT_API_KEY_ID"
          else
            echo "✅ APP_STORE_CONNECT_API_KEY_ID"
          fi

          if [ -z "$APP_STORE_CONNECT_ISSUER_ID" ]; then
            echo "❌ APP_STORE_CONNECT_ISSUER_ID 누락"
            MISSING_SECRETS="$MISSING_SECRETS APP_STORE_CONNECT_ISSUER_ID"
          else
            echo "✅ APP_STORE_CONNECT_ISSUER_ID"
          fi

          if [ -z "$APP_STORE_CONNECT_API_KEY_BASE64" ]; then
            echo "❌ APP_STORE_CONNECT_API_KEY_BASE64 누락"
            MISSING_SECRETS="$MISSING_SECRETS APP_STORE_CONNECT_API_KEY_BASE64"
          else
            echo "✅ APP_STORE_CONNECT_API_KEY_BASE64"
          fi

          if [ -z "$APPLE_ID" ]; then
            echo "❌ APPLE_ID 누락"
            MISSING_SECRETS="$MISSING_SECRETS APPLE_ID"
          else
            echo "✅ APPLE_ID: $APPLE_ID"
          fi

          if [ -n "$MISSING_SECRETS" ]; then
            echo ""
            echo "❌ ========================================"
            echo "❌ 누락된 GitHub Secrets:"
            for secret in $MISSING_SECRETS; do
              echo "  - $secret"
            done
            echo "❌ ========================================"
            echo "해결 방법: GitHub 저장소 Settings > Secrets and variables > Actions에서 누락된 Secrets를 추가해주세요."
            exit 1
          fi

          echo ""
          echo "✅ 모든 필수 Secrets가 설정되었습니다!"
          echo "🚀 ========================================"
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_PROVISIONING_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_BASE64 }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
          APPLE_ID: ${{ secrets.APPLE_ID }}

      - name: 📥 소스 코드 체크아웃
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}

      - name: ✅ 소스 코드 체크아웃 완료
        run: |
          echo "✅ ========================================"
          echo "✅ 소스 코드 체크아웃 완료"
          echo "✅ ========================================"
          echo "📂 현재 디렉토리: $(pwd)"
          echo "📁 프로젝트 파일 확인:"
          ls -la | head -10
          echo "📦 package.json 버전 확인:"
          node -p "require('./package.json').version"
          echo "✅ ========================================"

      - name: 🔧 Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: ✅ Node.js 설정 완료
        run: |
          echo "✅ ========================================"
          echo "✅ Node.js 설정 완료"
          echo "✅ ========================================"
          echo "📦 Node.js 버전: $(node --version)"
          echo "📦 npm 버전: $(npm --version)"
          echo "✅ ========================================"

      - name: 📦 JavaScript 의존성 설치
        run: |
          echo "📦 ========================================"
          echo "📦 JavaScript 의존성 설치 시작"
          echo "📦 ========================================"
          npm ci
          echo "✅ JavaScript 의존성 설치 완료"
          echo "📊 설치된 패키지 수: $(ls node_modules | wc -l)"
          echo "📦 ========================================"

      - name: 🍎 Xcode 설정
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: ✅ Xcode 설정 완료
        run: |
          echo "✅ ========================================"
          echo "✅ Xcode 설정 완료"
          echo "✅ ========================================"
          echo "🍎 Xcode 버전: $(xcodebuild -version)"
          echo "🍎 사용 가능한 SDK:"
          xcodebuild -showsdks | grep iOS
          echo "✅ ========================================"

      - name: 💎 Ruby 설정
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'

      - name: ✅ Ruby 설정 완료
        run: |
          echo "✅ ========================================"
          echo "✅ Ruby 설정 완료"
          echo "✅ ========================================"
          echo "💎 Ruby 버전: $(ruby --version)"
          echo "💎 Bundler 버전: $(bundle --version)"
          echo "✅ ========================================"

      - name: 💎 Fastlane 설치 (Bundle Install)
        run: |
          echo "💎 ========================================"
          echo "💎 Fastlane 설치 시작"
          echo "💎 ========================================"
          echo "📂 iOS 디렉토리로 이동 중..."
          cd ios

          echo "📋 Gemfile 내용 확인:"
          cat Gemfile

          echo ""
          echo "📦 Bundle install 실행 중..."
          bundle install

          echo ""
          echo "✅ Bundle install 완료!"
          echo "💎 설치된 Fastlane 버전: $(bundle exec fastlane --version | head -1)"
          echo "💎 ========================================"

      - name: 🏗️ CocoaPods 설치
        run: |
          echo "🏗️ ========================================"
          echo "🏗️ CocoaPods 설치 시작"
          echo "🏗️ ========================================"
          gem install cocoapods -N
          echo "📦 CocoaPods 버전: $(pod --version)"
          echo "📂 iOS 디렉토리로 이동하여 Pod 설치..."
          cd ios && pod install --repo-update
          echo "✅ CocoaPods 설치 완료"
          echo "📊 설치된 Pod 수:"
          ls ios/Pods | grep -v "Headers\|Target" | wc -l
          echo "🏗️ ========================================"

      # 인증서 설치 (아카이브 빌드에 필요)
      - name: 🔐 인증서 설치 사전 검증
        run: |
          echo "🔐 ========================================"
          echo "🔐 Apple Distribution 인증서 설치 사전 검증"
          echo "🔐 ========================================"
          echo "📋 인증서 설치 전 키체인 상태:"
          security list-keychains -d user
          echo ""
          echo "🔍 GitHub Secrets 검증:"
          if [ -z "${{ secrets.APPLE_CERTIFICATE_BASE64 }}" ]; then
            echo "❌ APPLE_CERTIFICATE_BASE64 Secret이 설정되지 않았습니다!"
            exit 1
          else
            echo "✅ APPLE_CERTIFICATE_BASE64 Secret 존재함"
            echo "📊 인증서 데이터 길이: ${#APPLE_CERTIFICATE_BASE64}"
          fi

          if [ -z "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" ]; then
            echo "❌ APPLE_CERTIFICATE_PASSWORD Secret이 설정되지 않았습니다!"
            exit 1
          else
            echo "✅ APPLE_CERTIFICATE_PASSWORD Secret 존재함"
          fi
          echo "🔐 ========================================"
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}

      - name: 🔐 Apple Distribution 인증서 설치
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          keychain: signing_temp
          create-keychain: true

      - name: ✅ 인증서 설치 완료 확인
        run: |
          echo "✅ ========================================"
          echo "✅ Apple Distribution 인증서 설치 완료"
          echo "✅ ========================================"
          echo "🔍 설치된 키체인 목록:"
          security list-keychains -d user
          echo ""
          echo "🔍 설치된 코드 사이닝 인증서:"
          security find-identity -v -p codesigning
          echo ""
          echo "🔍 기본 키체인:"
          security default-keychain
          echo "✅ ========================================"

      # 프로비저닝 프로파일 설치
      - name: 📱 프로비저닝 프로파일 설치
        env:
          PROVISIONING_PROFILE_BASE64: ${{ secrets.APPLE_PROVISIONING_PROFILE_BASE64 }}
        run: |
          echo "📱 ========================================"
          echo "📱 프로비저닝 프로파일 설치 시작"
          echo "📱 ========================================"

          echo "📂 프로파일 디렉토리 생성 중..."
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "✅ 프로비저닝 프로파일 디렉토리 생성 완료"

          echo "🔍 Base64 프로파일 디코딩 중..."
          echo "$PROVISIONING_PROFILE_BASE64" | base64 --decode > profile.mobileprovision
          echo "✅ 프로파일 디코딩 완료"
          echo "📊 디코딩된 파일 크기: $(du -h profile.mobileprovision | cut -f1)"

          echo "📋 프로파일 정보 추출 중..."
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< $(security cms -D -i profile.mobileprovision))
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<< $(security cms -D -i profile.mobileprovision))

          echo "📋 추출된 프로파일 정보:"
          echo "  - UUID: $PROFILE_UUID"
          echo "  - Name: $PROFILE_NAME"

          # CLI 프로젝트용 프로파일인지 확인
          if [[ "$PROFILE_NAME" == *"expo"* ]]; then
            echo "❌ ========================================"
            echo "❌ 에러: Expo 프로파일이 감지되었습니다!"
            echo "❌ ========================================"
            echo "현재 프로파일: $PROFILE_NAME"
            echo ""
            echo "해결 방법:"
            echo "1. Apple Developer Console에서 CLI 프로젝트용 Distribution 프로파일 생성"
            echo "2. 해당 프로파일을 Base64로 인코딩"
            echo "3. GitHub Secrets의 APPLE_PROVISIONING_PROFILE_BASE64 업데이트"
            echo ""
            echo "CLI 프로젝트에는 Expo 프로파일을 사용할 수 없습니다."
            echo "❌ ========================================"
            exit 1
          fi

          echo "📂 프로파일 설치 중..."
          cp profile.mobileprovision ~/Library/MobileDevice/Provisioning\ Profiles/"$PROFILE_UUID".mobileprovision
          echo "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_NAME" >> $GITHUB_ENV

          echo "✅ 프로비저닝 프로파일 설치 완료!"
          echo "🔍 설치된 프로파일 확인:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/
          echo "📱 ========================================"

      - name: 📊 버전 정보 수집
        id: version
        run: |
          echo "📊 ========================================"
          echo "📊 버전 정보 수집 시작"
          echo "📊 ========================================"

          VERSION=$(node -p "require('./package.json').version")
          BUILD_NUMBER=$(git rev-list --count HEAD)

          echo "📦 수집된 버전 정보:"
          echo "  - 버전명: $VERSION"
          echo "  - 빌드 번호: $BUILD_NUMBER"
          echo "  - Git 커밋 수: $(git rev-list --count HEAD)"
          echo "  - 현재 브랜치: $(git branch --show-current)"
          echo "  - 최신 커밋: $(git log -1 --format='%h %s')"

          echo "version_name=$VERSION" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "📊 ========================================"

      - name: 🏗️ iOS 아카이브 빌드
        run: |
          echo "🏗️ ========================================"
          echo "🏗️ iOS 아카이브 빌드 시작"
          echo "🏗️ ========================================"

          echo "🔍 빌드 전 환경 확인:"
          echo "  - 설치된 키체인:"
          security list-keychains -d user
          echo "  - 코드 사이닝 인증서:"
          security find-identity -v -p codesigning

          echo ""
          echo "📋 빌드 설정 정보:"
          echo "  - 프로비저닝 프로파일: ${{ env.PROVISIONING_PROFILE_SPECIFIER }}"
          echo "  - 앱 버전: ${{ steps.version.outputs.version_name }}"
          echo "  - 빌드 번호: ${{ steps.version.outputs.build_number }}"
          echo "  - 아카이브 경로: build/Wit.xcarchive"

          echo ""
          echo "🚀 xcodebuild 아카이브 명령 실행 중..."
          echo "🏗️ ========================================"

          xcodebuild \
            -workspace ios/Wit.xcworkspace \
            -scheme Wit \
            -configuration Release \
            -archivePath build/Wit.xcarchive \
            -allowProvisioningUpdates \
            clean archive \
            CURRENT_PROJECT_VERSION=${{ steps.version.outputs.build_number }} \
            MARKETING_VERSION=${{ steps.version.outputs.version_name }} \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE_SPECIFIER="${{ env.PROVISIONING_PROFILE_SPECIFIER }}"

          echo "🏗️ ========================================"
          echo "✅ 아카이브 빌드 완료!"
          echo "🏗️ ========================================"
          echo "📁 생성된 아카이브 확인:"
          if [ -d "build/Wit.xcarchive" ]; then
            echo "  ✅ 아카이브 파일 존재함"
            echo "  📊 아카이브 크기: $(du -sh build/Wit.xcarchive | cut -f1)"
            echo "  📂 아카이브 내용:"
            ls -la build/Wit.xcarchive/
          else
            echo "  ❌ 아카이브 파일이 생성되지 않았습니다!"
            exit 1
          fi
          echo "🏗️ ========================================"

      - name: 🔑 App Store Connect API Key 설정
        run: |
          echo "🔑 ========================================"
          echo "🔑 App Store Connect API Key 설정 시작"
          echo "🔑 ========================================"

          echo "📂 API Key 디렉토리 생성 중..."
          mkdir -p ~/.appstoreconnect/private_keys

          echo "🔓 API Key 디코딩 및 저장 중..."
          echo "${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8

          API_KEY_PATH="$HOME/.appstoreconnect/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8"
          echo "APP_STORE_CONNECT_API_KEY_PATH=$API_KEY_PATH" >> $GITHUB_ENV

          echo "✅ API Key 설정 완료!"
          echo "📁 API Key 파일 확인:"
          echo "  - 경로: $API_KEY_PATH"
          echo "  - 파일 존재: $([ -f "$API_KEY_PATH" ] && echo "✅ 예" || echo "❌ 아니오")"
          echo "  - 파일 크기: $([ -f "$API_KEY_PATH" ] && du -h "$API_KEY_PATH" | cut -f1 || echo "N/A")"
          echo "🔑 ========================================"

      - name: Generate Release Notes from CHANGELOG.md
        id: read_changelog
        run: |
          echo "📋 CHANGELOG.md에서 최신 릴리즈 노트 생성 중..."

          VERSION="${{ steps.version.outputs.version_name }}"

          # CHANGELOG.md에서 최신 버전 부분만 추출
          if [ -f "CHANGELOG.md" ]; then
            # 최신 버전 섹션을 추출 (## v버전부터 다음 ## v버전 또는 파일 끝까지)
            CHANGELOG_CONTENT=$(awk "/## v${VERSION}/{flag=1; next} /## v/{flag=0} flag" CHANGELOG.md | sed '/^$/d' | head -20)
            
            if [ -n "$CHANGELOG_CONTENT" ]; then
              echo "✅ CHANGELOG.md에서 릴리즈 노트 추출 완료"
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "⚠️ CHANGELOG.md에서 해당 버전을 찾을 수 없어 기본 메시지 사용"
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "새로운 버전 v${VERSION}이 출시되었습니다." >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
          else
            echo "⚠️ CHANGELOG.md 파일이 없어 기본 메시지 사용"
            echo "changelog<<EOF" >> $GITHUB_OUTPUT
            echo "새로운 버전 v${VERSION}이 출시되었습니다." >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

          echo "📋 생성된 릴리즈 노트 미리보기:"
          echo "$(echo "$CHANGELOG_CONTENT" | head -5 | tr '\n' ' ')..."

      - name: 🚀 Fastlane TestFlight 직접 업로드
        run: |
          echo "🚀 ========================================"
          echo "🚀 아카이브 → TestFlight"
          echo "🚀 ========================================"

          echo "📂 iOS 디렉토리로 이동 중..."
          cd ios

          echo "🔧 환경 변수 설정 중..."
          # Release notes 설정
          CHANGELOG_CONTENT="${{ steps.read_changelog.outputs.changelog }}"
          echo "$CHANGELOG_CONTENT" > ../.changelog.txt
          export CHANGELOG="$(cat ../.changelog.txt)"

          # 🔐 모든 GitHub Secrets를 환경변수로 Export
          echo "🔐 GitHub Secrets를 Fastlane 환경변수로 설정 중..."

          # App Store Connect API 관련
          export APP_STORE_CONNECT_API_KEY_ID="${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}"
          export APP_STORE_CONNECT_ISSUER_ID="${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}"
          export APP_STORE_CONNECT_API_KEY_PATH="${{ env.APP_STORE_CONNECT_API_KEY_PATH }}"

          # Apple Developer 계정 관련
          export APPLE_ID="${{ secrets.APPLE_ID }}"
          export APPLE_TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"

          # 프로비저닝 프로파일 (동적으로 추출된 값)
          export PROVISIONING_PROFILE_SPECIFIER="${{ env.PROVISIONING_PROFILE_SPECIFIER }}"

          # 코드 사이닝 관련 (Fastfile에서 필요시 사용)
          export APPLE_CERTIFICATE_PASSWORD="${{ secrets.APPLE_CERTIFICATE_PASSWORD }}"

          echo "✅ 모든 환경변수 설정 완료"

          echo "🔍 설정된 환경 변수 확인:"
          echo "  - CHANGELOG(preview): $(echo "$CHANGELOG" | head -c 80 | tr '\n' ' ')..."
          echo "  - API_KEY_ID: $APP_STORE_CONNECT_API_KEY_ID"
          echo "  - API_KEY_PATH: $APP_STORE_CONNECT_API_KEY_PATH"
          echo "  - APPLE_ID: $APPLE_ID"
          echo "  - APPLE_TEAM_ID: $APPLE_TEAM_ID"
          echo "  - PROVISIONING_PROFILE: $PROVISIONING_PROFILE_SPECIFIER"

          echo ""
          echo "📋 업로드 준비 상태 확인:"
          echo "  - 아카이브 파일 존재: $([ -d "../build/Wit.xcarchive" ] && echo "✅ 예" || echo "❌ 아니오")"
          echo "  - API Key 파일 존재: $([ -f "$APP_STORE_CONNECT_API_KEY_PATH" ] && echo "✅ 예" || echo "❌ 아니오")"

          if [ ! -d "../build/Wit.xcarchive" ]; then
            echo "❌ 아카이브 파일이 없습니다!"
            exit 1
          fi

          if [ ! -f "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
            echo "❌ App Store Connect API Key 파일이 없습니다!"
            exit 1
          fi

          echo ""
          echo "🚀 Fastlane 직접 업로드 실행 중..."
          echo "🚀 ========================================"

          echo "🔍 Fastlane 실행 전 최종 확인:"
          echo "  - 현재 디렉토리: $(pwd)"
          echo "  - Fastfile 존재: $([ -f "fastlane/Fastfile" ] && echo "✅" || echo "❌")"
          echo "  - Bundle 상태: $(bundle --version)"

          # Fastlane 실행
          echo "🚀 실제 Fastlane 명령 실행..."
          bundle exec fastlane upload_archive_to_testflight

          echo "🚀 ========================================"
          echo "✅ TestFlight 업로드 완료!"
          echo "🚀 ========================================"

      - name: 🎉 배포 완료 로그
        run: |
          echo "🎉 ========================================"
          echo "🎉 TestFlight 배포 완료!"
          echo "🎉 ========================================"
          echo "📱 앱이 TestFlight에 성공적으로 업로드되었습니다."
          echo "📅 배포 완료 시간: $(date)"
          echo "📦 배포된 버전: ${{ steps.version.outputs.version_name }}"
          echo "🔢 빌드 번호: ${{ steps.version.outputs.build_number }}"
          echo ""
          echo "📋 다음 단계:"
          echo "  1. TestFlight에서 빌드 처리 완료 대기"
          echo "  2. 내부 테스터에게 알림 발송"
          echo "  3. 테스트 진행 후 App Store 출시 준비"
          echo "🎉 ========================================"

      - name: Upload iOS build artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-artifacts-${{ github.run_id }}
          path: |
            build/Wit.xcarchive
            build/ipa/*.ipa
            build/ExportOptions.plist
            ios/fastlane/report.xml
            /Users/runner/Library/Logs/gym
            /Users/runner/Library/Logs/fastlane
            /Users/runner/Library/Logs/xcodebuild
          if-no-files-found: ignore
          retention-days: 7

      # 성공 시에도 주요 아티팩트 업로드 (디버깅용)
      - name: Upload iOS build artifacts (on success)
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-success-${{ github.run_id }}
          path: |
            build/ipa/*.ipa
            ios/fastlane/report.xml
          if-no-files-found: ignore
          retention-days: 3

  update-readme:
    name: 📝 Update README
    needs: deploy-testflight
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get latest version
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "latest_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update README.md from CHANGELOG.md
        run: |
          echo "📄 README.md 업데이트 중 (CHANGELOG.md 기반)..."

          python3 << 'PYTHON_SCRIPT'
          import re
          import os
          from datetime import datetime

          def translate_category_to_korean(category_text):
              """영어 카테고리를 한국어로 변환"""
              category_translations = {
                  'New Features': '신규 기능',
                  'Bug Fixes': '버그 수정',
                  'Style': '스타일',
                  'Refactor': '리팩토링',
                  'Chores': '작업 정리',
                  'Documentation': '문서',
                  'Tests': '테스트',
                  'Performance': '성능',
                  'Security': '보안',
                  'General': '일반'
              }
              return category_translations.get(category_text, category_text)

          def convert_changelog_to_korean(content):
              """CHANGELOG 내용의 영어 카테고리를 한국어로 변환"""
              # **카테고리** 형식의 패턴 찾기
              pattern = r'\*\*([^*]+)\*\*'
              
              def replace_category(match):
                  category = match.group(1)
                  korean_category = translate_category_to_korean(category)
                  return f"**{korean_category}**"
              
              return re.sub(pattern, replace_category, content)

          try:
              # CHANGELOG.md에서 최신 버전 정보 추출
              with open('CHANGELOG.md', 'r', encoding='utf-8') as f:
                  changelog_content = f.read()
              
              # 첫 번째 버전 섹션 찾기 (## [버전] - 날짜 형식)
              version_pattern = r'## \[([^\]]+)\] - (\d{4}-\d{2}-\d{2})'
              version_match = re.search(version_pattern, changelog_content)
              
              if not version_match:
                  print("❌ CHANGELOG.md에서 버전 정보를 찾을 수 없습니다")
                  exit(1)
              
              version = version_match.group(1)
              date = version_match.group(2)
              
              print(f"📋 최신 버전: v{version} ({date})")
              
              # 첫 번째 버전의 변경사항 추출
              # 첫 번째 ## [버전]부터 다음 ## [버전] 또는 --- 까지
              first_version_start = version_match.start()
              
              # 다음 버전 섹션 찾기
              next_version_pattern = r'\n## \[[^\]]+\] - \d{4}-\d{2}-\d{2}'
              next_version_match = re.search(next_version_pattern, changelog_content[first_version_start + 1:])
              
              if next_version_match:
                  first_version_end = first_version_start + 1 + next_version_match.start()
              else:
                  # 다음 버전이 없으면 --- 구분자 찾기
                  separator_match = re.search(r'\n---\n', changelog_content[first_version_start:])
                  if separator_match:
                      first_version_end = first_version_start + separator_match.start()
                  else:
                      first_version_end = len(changelog_content)
              
              # 첫 번째 버전의 내용 추출
              first_version_content = changelog_content[first_version_start:first_version_end].strip()
              
              # 버전 헤더 제거하고 내용만 추출
              content_lines = first_version_content.split('\n')[2:]  # 첫 두 줄 (헤더와 빈 줄) 제거
              changes_content = '\n'.join(content_lines).strip()
              
              # 영어 카테고리를 한국어로 변환
              korean_changes_content = convert_changelog_to_korean(changes_content)
              
              print(f"📋 추출된 변경사항 길이: {len(changes_content)} 문자")
              print(f"🔄 카테고리 한국어 변환 완료")
              
              # README.md 생성
              with open('README.md', 'w', encoding='utf-8') as f:
                  f.write("# Wit App\n\n")
                  f.write("여행 친구 찾기\n\n")
                  f.write("---\n\n")
                  f.write(f"## 최신 버전: v{version} ({date})\n\n")
                  
                  # 변경사항 섹션
                  f.write("### 변경 사항\n\n")
                  
                  if korean_changes_content and korean_changes_content.strip():
                      f.write(f"{korean_changes_content}\n\n")
                  else:
                      f.write(f"**일반**\n")
                      f.write(f"- v{version}의 변경사항이 반영되었습니다.\n\n")
                  
                  # 이전 변경사항 링크
                  f.write("### 이전 변경 사항\n\n")
                  f.write("[이전 변경사항 보기](PREVIOUS_CHANGES.md)\n\n")
                  
                  # 문서 섹션
                  f.write("**DOCUMENTATION**\n\n")
                  f.write("- Expo -> Cli로 변경되었습니다.\n\n")
                  f.write("---\n\n")
                  f.write("<!-- 자동 생성된 README (카테고리 한국어 변환) -->\n")
              
              print("✅ README.md 업데이트 완료 (CHANGELOG.md 기반, 카테고리 한국어 변환)")
              
              # PREVIOUS_CHANGES.md 생성 (맨 위 버전 제외한 나머지 모든 버전)
              print("📋 PREVIOUS_CHANGES.md 업데이트 중...")
              
              # 맨 위 버전을 제외한 나머지 내용 추출
              if first_version_end < len(changelog_content):
                  # 맨 위 버전 이후의 모든 내용 (--- 구분자 포함)
                  remaining_content = changelog_content[first_version_end:].strip()
                  
                  # PREVIOUS_CHANGES.md 생성
                  with open('PREVIOUS_CHANGES.md', 'w', encoding='utf-8') as f:
                      f.write("# 이전 변경사항\n\n")
                      
                      if remaining_content:
                          # --- 구분자가 있으면 제거하고 시작
                          if remaining_content.startswith('---'):
                              remaining_content = remaining_content[3:].strip()
                          
                          # 영어 카테고리를 한국어로 변환
                          korean_remaining_content = convert_changelog_to_korean(remaining_content)
                          f.write(f"{korean_remaining_content}\n")
                      else:
                          f.write("이전 변경사항이 없습니다.\n")
                  
                  print("✅ PREVIOUS_CHANGES.md 업데이트 완료 (맨 위 버전 제외, 카테고리 한국어 변환)")
              else:
                  print("ℹ️ 이전 버전이 없어 PREVIOUS_CHANGES.md를 빈 파일로 생성합니다.")
                  with open('PREVIOUS_CHANGES.md', 'w', encoding='utf-8') as f:
                      f.write("# 이전 변경사항\n\n")
                      f.write("이전 변경사항이 없습니다.\n")
              
              # GitHub Actions 출력 설정
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"latest_version={version}\n")
              
          except Exception as e:
              print(f"❌ README.md 업데이트 실패: {e}")
              import traceback
              print(f"📋 상세 오류:\n{traceback.format_exc()}")
              exit(1)
          PYTHON_SCRIPT

      - name: Commit and push README and PREVIOUS_CHANGES update
        run: |
          git add README.md PREVIOUS_CHANGES.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: update README and PREVIOUS_CHANGES with version v${{ steps.version.outputs.latest_version }} [skip ci]"
            git push origin main
            echo "✅ README.md와 PREVIOUS_CHANGES.md 업데이트 완료 및 main 브랜치 푸시 완료"
          else
            echo "No changes to commit."
          fi

      - name: Auto Merge PR (main -> release)
        run: |
          echo "🔍 자동 병합 준비 중..."
          echo "🔍 현재 브랜치: $(git branch --show-current)"
          echo "🔍 최신 커밋: $(git log -1 --format='%h %s')"

          # main -> release PR 찾기 (더 간단한 방법)
          echo "🔍 main -> release PR 검색 중..."

          PR_NUMBER=$(gh pr list \
            --base release \
            --head main \
            --state open \
            --limit 1 \
            --json number \
            --jq '.[0].number // empty')

          if [ -n "$PR_NUMBER" ]; then
            echo "✅ PR #$PR_NUMBER 발견됨 (main -> release)"
            
            # PR 상세 정보 확인
            echo "📋 PR 상태 확인 중..."
            PR_INFO=$(gh pr view $PR_NUMBER --json state,mergeable,title,url)
            PR_STATE=$(echo "$PR_INFO" | jq -r '.state')
            PR_MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable')
            PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
            PR_URL=$(echo "$PR_INFO" | jq -r '.url')
            
            echo "📊 PR 정보:"
            echo "  - 번호: #$PR_NUMBER"
            echo "  - 제목: $PR_TITLE"
            echo "  - 상태: $PR_STATE"
            echo "  - 병합 가능: $PR_MERGEABLE"
            echo "  - URL: $PR_URL"
            
            # 병합 조건 확인
            if [ "$PR_STATE" = "OPEN" ]; then
              if [ "$PR_MERGEABLE" = "MERGEABLE" ] || [ "$PR_MERGEABLE" = "null" ]; then
                echo ""
                echo "🎉 ========================================"
                echo "🎉 모든 배포 과정이 성공했습니다!"
                echo "🎉 PR #$PR_NUMBER을 자동 병합합니다."
                echo "🎉 ========================================"
                
                # 병합 실행 (squash merge 사용)
                echo "🔄 병합 실행 중..."
                gh pr merge $PR_NUMBER \
                  --squash \
                  --admin \
                  --delete-branch \
                  --subject "🚀 Deploy v${{ steps.version.outputs.latest_version }} to TestFlight"
                
                echo ""
                echo "✅ ========================================"
                echo "✅ PR #$PR_NUMBER 병합 완료!"
                echo "✅ ========================================"
                echo "🗑️ main 브랜치 자동 삭제 완료"
                echo "📱 TestFlight 배포 및 PR 병합 모두 성공!"
                echo "✅ ========================================"
              else
                echo "⚠️ ========================================"
                echo "⚠️ PR 병합 불가능"
                echo "⚠️ ========================================"
                echo "❌ 병합 상태: $PR_MERGEABLE"
                echo "💡 수동으로 충돌을 해결한 후 병합해주세요."
                echo "🔗 PR 링크: $PR_URL"
                echo "⚠️ ========================================"
              fi
            else
              echo "⚠️ PR이 OPEN 상태가 아닙니다 (현재: $PR_STATE)"
            fi
          else
            echo "ℹ️ ========================================"
            echo "ℹ️ main -> release PR을 찾을 수 없습니다"
            echo "ℹ️ ========================================"
            echo "📋 현재 열린 PR 목록:"
            gh pr list --state open --limit 5 || echo "  - 열린 PR이 없습니다"
            echo ""
            echo "💡 main -> release PR이 없으면 자동 병합을 건너뜁니다."
            echo "ℹ️ ========================================"
          fi
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: 🎉 전체 배포 프로세스 완료
        run: |
          echo "🎉 ========================================"
          echo "🎉 전체 배포 프로세스 완료!"
          echo "🎉 ========================================"
          echo "✅ 1. iOS 아카이브 빌드 완료"
          echo "✅ 2. TestFlight 업로드 완료"
          echo "✅ 3. README.md 업데이트 완료 (CHANGELOG.md 기반, 카테고리 한국어 변환)"
          echo "✅ 4. PREVIOUS_CHANGES.md 업데이트 완료 (맨 위 버전 제외)"
          echo "✅ 5. main 브랜치 푸시 완료"
          echo "✅ 6. PR 자동 병합 시도 완료"
          echo ""
          echo "📱 배포된 버전: v${{ steps.version.outputs.latest_version }}"
          echo "📅 배포 완료 시간: $(date)"
          echo ""
          echo "📋 다음 단계:"
          echo "  1. TestFlight에서 빌드 처리 완료 대기 (보통 5-10분)"
          echo "  2. 내부 테스터에게 자동 알림 발송"
          echo "  3. 테스트 진행 후 App Store 출시 준비"
          echo ""
          echo "🔗 TestFlight: https://appstoreconnect.apple.com"
          echo "🎉 ========================================"
