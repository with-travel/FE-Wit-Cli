name: 📝 CHANGELOG Update

on:
  workflow_run:
    workflows: ['🧪 Build Test']
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  changelog-update:
    name: 📝 CHANGELOG Update
    runs-on: macos-14
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      new_version: ${{ steps.versioning.outputs.new_version }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get PR Number from workflow run
        id: get_pr
        run: |
          # workflow_run에서 PR 번호 추출
          PR_NUMBER=$(gh api repos/${{ github.repository }}/pulls \
            --jq '.[] | select(.head.sha == "${{ github.event.workflow_run.head_sha }}") | .number' \
            | head -1)

          if [ -z "$PR_NUMBER" ]; then
            echo "❌ PR 번호를 찾을 수 없습니다."
            exit 1
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "✅ PR 번호: $PR_NUMBER"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Request CodeRabbit Summary
        run: |
          echo "🤖 CodeRabbit에게 리뷰 요청 중..."
          gh pr comment ${{ steps.get_pr.outputs.pr_number }} --body "@coderabbitai review"
          echo "✅ CodeRabbit 리뷰 요청 완료"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Wait for CodeRabbit Summary (Expo 방식 개선)
        id: detect_summary
        continue-on-error: true
        timeout-minutes: 10
        run: |
          PR_NUMBER="${{ steps.get_pr.outputs.pr_number }}"
          MAX_ATTEMPTS=120  # 10분 = 120 * 5초
          ATTEMPT=0

          echo "🔍 PR #$PR_NUMBER에서 CodeRabbit Summary 업데이트 감지 시작..."
          echo "최대 대기 시간: 10분 (5초마다 체크)"

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "[$ATTEMPT/$MAX_ATTEMPTS] CodeRabbit Summary 확인 중... ($(date '+%H:%M:%S'))"
            
            # GitHub API로 PR HTML 가져오기 (Expo 방식)
            curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                 -H "Accept: application/vnd.github.v3.html" \
                 "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
                 > pr_content.html
            
            # "No description provided" 체크
            if grep -q "No description provided" pr_content.html; then
              echo "❌ 아직 'No description provided' 상태입니다"
            elif grep -q "Summary by CodeRabbit" pr_content.html; then
              echo "✅ CodeRabbit Summary 발견! 파싱을 시작합니다"
              echo "summary_found=true" >> $GITHUB_OUTPUT
              break
            else
              echo "⏳ CodeRabbit Summary 아직 없음"
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 5
            fi
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "⚠️ 10분 대기 후에도 CodeRabbit Summary를 찾을 수 없습니다"
            echo "summary_found=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Grant execute permission to scripts
        run: |
          echo "📋 스크립트 파일 권한 설정 중..."
          if [ -f ".github/scripts/rn_version_manager.sh" ]; then
            chmod +x .github/scripts/rn_version_manager.sh
            echo "✅ rn_version_manager.sh 권한 설정 완료"
          else
            echo "❌ rn_version_manager.sh 파일을 찾을 수 없습니다!"
            exit 1
          fi

          if [ -f ".github/scripts/changelog_manager.py" ]; then
            chmod +x .github/scripts/changelog_manager.py
            echo "✅ changelog_manager.py 권한 설정 완료"
          else
            echo "⚠️ changelog_manager.py 파일을 찾을 수 없습니다 (선택적)"
          fi

      - name: Increment version and sync native files
        id: versioning
        run: |
          NEW_VERSION=$(./.github/scripts/rn_version_manager.sh increment)
          ./.github/scripts/rn_version_manager.sh sync
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Dynamic Summary Parsing and CHANGELOG Update
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          PR_NUMBER="${{ steps.get_pr.outputs.pr_number }}"
          VERSION="${{ steps.versioning.outputs.new_version }}"
          TIMESTAMP=$(date '+%Y-%m-%dT%H:%M:%SZ')

          echo "📝 CodeRabbit Summary 동적 파싱 시작..."

          # Summary 섹션 추출 (개선된 방식)
          echo "🔍 PR HTML에서 CodeRabbit Summary 추출 중..."

          # 1. HTML에서 Summary 섹션 추출
          sed -n '/<h2[^>]*>Summary by CodeRabbit<\/h2>/,/<\/div>/p' pr_content.html > summary_section.html

          # 2. Summary가 제대로 추출되었는지 확인
          SUMMARY_SIZE=$(wc -c < summary_section.html)
          echo "📄 추출된 Summary 섹션 크기: ${SUMMARY_SIZE} bytes"

          if [ "$SUMMARY_SIZE" -lt 100 ]; then
            echo "⚠️ Summary 섹션이 너무 작습니다. 다른 방식으로 추출 시도..."
            # 더 넓은 범위로 추출
            sed -n '/Summary by CodeRabbit/,/<!-- end of auto-generated comment/p' pr_content.html > summary_section.html
            SUMMARY_SIZE=$(wc -c < summary_section.html)
            echo "📄 재추출된 Summary 섹션 크기: ${SUMMARY_SIZE} bytes"
          fi

          # 3. HTML 태그 제거하고 텍스트만 추출
          cat summary_section.html | sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g; s/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&quot;/"/g' > raw_summary.txt

          # 4. 추출된 내용 확인
          echo "📋 추출된 Summary 내용 미리보기:"
          echo "===================="
          head -10 raw_summary.txt
          echo "===================="

          echo "🔍 동적 카테고리 추출 중..."
          echo "📄 Summary 섹션 미리보기:"
          head -10 summary_section.html

          # Python으로 동적 파싱
          cat > parse_changelog.py << 'EOF'
          import re
          import json
          import html
          import sys
          import os
          from datetime import datetime

          def extract_items_from_section(html_content, section_title):
              """특정 섹션의 아이템들을 추출"""
              print(f"📋 '{section_title}' 섹션에서 아이템 추출 중...")
              
              # 다양한 패턴으로 섹션 찾기
              patterns = [
                  f'<strong[^>]*>{re.escape(section_title)}[^<]*</strong>',
                  f'<li[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong>',
                  f'<p[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong></p>'
              ]
              
              section_match = None
              for pattern in patterns:
                  section_match = re.search(pattern, html_content, re.IGNORECASE)
                  if section_match:
                      print(f"✅ 패턴 매치: {pattern[:50]}...")
                      break
              
              if not section_match:
                  print(f"❌ '{section_title}' 섹션을 찾을 수 없습니다")
                  return []
              
              # 섹션 이후의 ul 태그 찾기
              after_section = html_content[section_match.end():]
              ul_match = re.search(r'<ul[^>]*>(.*?)</ul>', after_section, re.DOTALL)
              
              if not ul_match:
                  print(f"❌ '{section_title}' 섹션 이후 ul 태그를 찾을 수 없습니다")
                  return []
              
              # li 태그들에서 텍스트 추출
              ul_content = ul_match.group(1)
              li_items = re.findall(r'<li[^>]*>(.*?)</li>', ul_content, re.DOTALL)
              
              items = []
              for item in li_items:
                  # HTML 태그 제거하고 텍스트만 추출
                  clean_text = re.sub(r'<[^>]*>', '', item)
                  clean_text = html.unescape(clean_text).strip()
                  if clean_text:
                      items.append(clean_text)
                      print(f"  📝 아이템: {clean_text[:50]}...")
              
              print(f"✅ '{section_title}' 섹션에서 {len(items)}개 아이템 추출 완료")
              return items

          def detect_categories(content):
              """텍스트에서 동적으로 카테고리 감지 - 개선된 방식"""
              print("🔍 텍스트에서 카테고리 감지 시작...")
              print(f"📄 텍스트 내용 길이: {len(content)} characters")
              
              detected_categories = {}
              
              # 텍스트를 줄별로 분리
              lines = content.split('\n')
              current_category = None
              current_items = []
              
              for line in lines:
                  line = line.strip()
                  if not line:
                      continue
                  
                  print(f"🔍 처리 중인 라인: '{line[:50]}...'")
                  
                  # 카테고리 제목 감지 (- 로 시작하는 주요 섹션들)
                  if line in ['New Features', 'Bug Fixes', 'Style', 'Refactor', 'Chores', 'Features', 'Fixes', 'Changes', 'Documentation', 'Tests', 'Performance', 'Security']:
                      # 이전 카테고리가 있다면 저장
                      if current_category and current_items:
                          safe_key = re.sub(r'[^a-zA-Z0-9가-힣]', '_', current_category.lower()).strip('_')
                          detected_categories[safe_key] = {
                              'title': current_category,
                              'items': current_items.copy()
                          }
                          print(f"✅ 카테고리 저장: '{current_category}' -> '{safe_key}' ({len(current_items)}개 아이템)")
                      
                      # 새 카테고리 시작
                      current_category = line
                      current_items = []
                      print(f"🏷️ 새 카테고리 시작: '{current_category}'")
                      
                  # 아이템 감지 (들여쓰기나 - 로 시작하는 항목들)
                  elif current_category and (line.startswith('  -') or line.startswith('-') or line.startswith('•')):
                      # 불릿 포인트 제거하고 텍스트만 추출
                      item_text = re.sub(r'^[\s\-•]+', '', line).strip()
                      if item_text and len(item_text) > 3:  # 의미있는 내용만
                          current_items.append(item_text)
                          print(f"  📝 아이템 추가: '{item_text[:50]}...'")
                  
                  # 일반 텍스트도 아이템으로 간주 (카테고리 다음에 오는 설명문)
                  elif current_category and len(line) > 10 and not line.endswith(':'):
                      current_items.append(line)
                      print(f"  📝 설명 아이템 추가: '{line[:50]}...'")
              
              # 마지막 카테고리 저장
              if current_category and current_items:
                  safe_key = re.sub(r'[^a-zA-Z0-9가-힣]', '_', current_category.lower()).strip('_')
                  detected_categories[safe_key] = {
                      'title': current_category,
                      'items': current_items.copy()
                  }
                  print(f"✅ 마지막 카테고리 저장: '{current_category}' -> '{safe_key}' ({len(current_items)}개 아이템)")
              
              print(f"🎯 최종 감지된 카테고리 수: {len(detected_categories)}")
              for category, data in detected_categories.items():
                  print(f"  📂 {category}: {data['title']} ({len(data['items'])}개 아이템)")
                  for item in data['items'][:2]:  # 처음 2개만 미리보기
                      print(f"    • {item[:50]}...")
              
              return detected_categories

          def main():
              # 환경 변수에서 값 가져오기
              version = os.environ.get('VERSION')
              pr_number = int(os.environ.get('PR_NUMBER'))
              timestamp = os.environ.get('TIMESTAMP')
              
              try:
                  # 텍스트 파일 읽기 (HTML 태그 제거된 버전)
                  with open('raw_summary.txt', 'r', encoding='utf-8') as f:
                      text_content = f.read()
                  
                  print(f"📄 읽어온 텍스트 내용 미리보기:")
                  print("=" * 50)
                  print(text_content[:500] + "..." if len(text_content) > 500 else text_content)
                  print("=" * 50)
                  
                  # 동적 카테고리 감지
                  categories = detect_categories(text_content)
                  
                  print("🎯 감지된 카테고리들:")
                  for key, value in categories.items():
                      print(f"  - {key}: {value['title']} ({len(value['items'])}개 항목)")
                      for item in value['items'][:3]:  # 첫 3개 아이템만 미리보기
                          print(f"    • {item[:80]}...")
                  
                  # Raw summary 읽기 (텍스트 버전 사용)
                  raw_summary = text_content.strip() if text_content else "Summary parsing failed"
                  
                  # 새로운 릴리즈 엔트리 생성 (Expo 형식 참조)
                  new_release = {
                      "version": version,
                      "date": timestamp[0:10],  # YYYY-MM-DD 형식
                      "timestamp": timestamp,
                      "pr_number": pr_number,
                      "raw_summary": raw_summary,
                      "changes": {}
                  }
                  
                  # 동적 카테고리를 changes에 추가 (Expo parsed_changes 방식)
                  for key, value in categories.items():
                      new_release["changes"][key] = value["items"]
                      print(f"📝 changes에 추가: {key} -> {len(value['items'])}개 아이템")
                  
                  # CHANGELOG.json 업데이트
                  try:
                      with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                          changelog_data = json.load(f)
                  except (FileNotFoundError, json.JSONDecodeError):
                      changelog_data = {"releases": []}
                  
                  # 새 릴리즈를 맨 앞에 추가
                  changelog_data["releases"].insert(0, new_release)
                  
                  # 파일 저장
                  with open('CHANGELOG.json', 'w', encoding='utf-8') as f:
                      json.dump(changelog_data, f, indent=2, ensure_ascii=False)
                  
                  print("✅ CHANGELOG.json 업데이트 완료!")
                  total_items = sum(len(data['items']) for data in categories.values())
                  print(f"📊 총 {len(categories)}개 카테고리, {total_items}개 변경사항")
                  
              except Exception as e:
                  print(f"❌ 파싱 오류: {e}")
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOF

          # 환경 변수 설정하고 Python 스크립트 실행
          export VERSION="$VERSION"
          export PR_NUMBER="$PR_NUMBER"
          export TIMESTAMP="$TIMESTAMP"

          python3 parse_changelog.py

      - name: Generate CHANGELOG.md from JSON
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          echo "📄 CHANGELOG.json에서 CHANGELOG.md 재생성 중..."

          python3 << 'PYTHON_SCRIPT'
          import json

          try:
              with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                  data = json.load(f)
              
              with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
                  f.write("# CHANGELOG\n\n")
                  f.write("이 파일은 워크플로우에 의해 자동으로 생성됩니다.\n")

                  for release in data['releases']:
                      f.write(f"## v{release['version']} ({release['timestamp'][0:10]})\n")
                      
                      # 카테고리별로 정리된 형식으로 출력 (Expo 방식 개선)
                      if release['changes']:
                          for category_key, items in release['changes'].items():
                              if items and len(items) > 0:
                                  # 카테고리명을 한국어로 변환 (영어 원문 기준)
                                  category_titles = {
                                      'new_features': '새로운 기능',
                                      'bug_fixes': '버그 수정', 
                                      'style': '스타일 개선',
                                      'refactor': '리팩토링',
                                      'chores': '작업 정리',
                                      'features': '새로운 기능',
                                      'documentation': '문서화',
                                      'test': '테스트',
                                      'general': '일반',
                                      # 추가 매핑
                                      'ui': 'UI 개선',
                                      'performance': '성능 개선',
                                      'security': '보안',
                                      'api': 'API',
                                      'fixes': '수정사항'
                                  }
                                  
                                  title = category_titles.get(category_key.lower(), category_key.replace('_', ' ').title())
                                  f.write(f"\n**{title}**\n")
                                  
                                  for item in items:
                                      f.write(f"- {item}\n")
                      else:
                          # changes가 비어있는 경우 기본 메시지
                          f.write(f"\n**일반**\n")
                          f.write(f"- PR #{release.get('pr_number', 'N/A')}의 변경사항이 반영되었습니다.\n")
                      
                      f.write("\n---\n\n")
              
              print("✅ CHANGELOG.md 재생성 완료!")
              
          except Exception as e:
              print(f"❌ CHANGELOG.md 생성 실패: {e}")
              exit(1)
          PYTHON_SCRIPT

      - name: Generate PREVIOUS_CHANGES.md from JSON
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          echo "📄 PREVIOUS_CHANGES.md 생성 중..."

          python3 << 'PYTHON_SCRIPT'
          import json
          import os

          def get_category_title(key):
              """카테고리 키를 한국어 제목으로 변환"""
              category_titles = {
                  'new_features': '새로운 기능',
                  'bug_fixes': '버그 수정', 
                  'style': '스타일 개선',
                  'refactor': '리팩토링',
                  'chores': '작업 정리',
                  'features': '새로운 기능',
                  'documentation': '문서화',
                  'test': '테스트',
                  'general': '일반',
                  'ui': 'UI 개선',
                  'performance': '성능 개선',
                  'security': '보안',
                  'api': 'API',
                  'fixes': '수정사항'
              }
              return category_titles.get(key.lower(), key.replace('_', ' ').title())

          try:
              if os.path.exists('CHANGELOG.json'):
                  with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                      data = json.load(f)
                  
                  with open('PREVIOUS_CHANGES.md', 'w', encoding='utf-8') as f:
                      f.write("# 이전 변경사항\n\n")
                      
                      # 최신 버전(인덱스 0)을 제외한 나머지 버전들 처리
                      previous_releases = data.get('releases', [])[1:]
                      
                      if not previous_releases:
                          f.write("아직 이전 변경사항이 없습니다.\n")
                      else:
                          for release in previous_releases:
                              version = release.get('version', 'Unknown')
                              date = release.get('timestamp', release.get('date', ''))[:10]  # YYYY-MM-DD
                              pr_number = release.get('pr_number', 'N/A')
                              changes = release.get('changes', {})
                              
                              f.write(f"## [{version}] - {date}\n\n")
                              
                              # 변경사항이 있는 경우
                              if changes and any(items for items in changes.values() if items):
                                  for category_key, items in changes.items():
                                      if items and len(items) > 0:
                                          title = get_category_title(category_key)
                                          f.write(f"**{title}**\n")
                                          for item in items:
                                              f.write(f"- {item}\n")
                                          f.write("\n")
                              else:
                                  # 변경사항이 없는 경우 기본 메시지
                                  f.write(f"**일반**\n")
                                  f.write(f"- PR #{pr_number}의 변경사항이 반영되었습니다.\n\n")
                              
                              f.write("---\n\n")
                  
                  print("✅ PREVIOUS_CHANGES.md 생성 완료")
              else:
                  # CHANGELOG.json이 없는 경우
                  with open('PREVIOUS_CHANGES.md', 'w', encoding='utf-8') as f:
                      f.write("# 이전 변경사항\n\n")
                      f.write("아직 이전 변경사항이 없습니다.\n")
                  print("⚠️ CHANGELOG.json이 없어 기본 PREVIOUS_CHANGES.md 생성")
                  
          except Exception as e:
              print(f"❌ PREVIOUS_CHANGES.md 생성 실패: {e}")
              import traceback
              print(f"📋 상세 오류 정보:\n{traceback.format_exc()}")
              
              # 실패해도 워크플로우를 중단하지 않도록 기본 파일 생성
              try:
                  with open('PREVIOUS_CHANGES.md', 'w', encoding='utf-8') as f:
                      f.write("# 이전 변경사항\n\n")
                      f.write("변경사항 처리 중 오류가 발생했습니다.\n")
                  print("⚠️ 기본 PREVIOUS_CHANGES.md 파일을 생성했습니다.")
              except Exception as fallback_error:
                  print(f"❌ 기본 파일 생성도 실패: {fallback_error}")
              
              # 워크플로우 계속 진행을 위해 exit(1) 제거
              pass
          PYTHON_SCRIPT

      - name: Commit and push CHANGELOG updates
        run: |
          git add package.json ios/Wit/Info.plist android/app/build.gradle CHANGELOG.json CHANGELOG.md PREVIOUS_CHANGES.md
          if ! git diff --staged --quiet; then
            git commit -m "chore: update CHANGELOG to v${{ steps.versioning.outputs.new_version }} [skip ci]"
            git push origin main
          else
            echo "No CHANGELOG changes to commit."
          fi

      - name: Create and push Git tag
        run: |
          git tag "v${{ steps.versioning.outputs.new_version }}"
          git push origin "v${{ steps.versioning.outputs.new_version }}"

      - name: Verify CHANGELOG generation
        run: |
          echo "📋 생성된 CHANGELOG.md 확인:"
          if [ -f "CHANGELOG.md" ]; then
            echo "✅ CHANGELOG.md 파일 존재"
            echo "📄 최신 버전 내용 미리보기:"
            head -20 CHANGELOG.md
          else
            echo "❌ CHANGELOG.md 파일이 생성되지 않았습니다!"
            exit 1
          fi

      - name: 🎉 CHANGELOG Update Success
        run: |
          echo "✅ CHANGELOG 업데이트가 성공했습니다!"
          echo "📦 새 버전: v${{ steps.versioning.outputs.new_version }}"
          echo "📋 다음 단계: TestFlight 배포 워크플로우가 자동으로 시작됩니다."
