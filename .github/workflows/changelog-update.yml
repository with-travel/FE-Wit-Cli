name: 📝 CHANGELOG Update

on:
  workflow_run:
    workflows: ['🧪 Build Test']
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  changelog-update:
    name: 📝 CHANGELOG Update
    runs-on: macos-14
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      new_version: ${{ steps.versioning.outputs.new_version }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get PR Number from workflow run
        id: get_pr
        run: |
          # workflow_run에서 PR 번호 추출
          PR_NUMBER=$(gh api repos/${{ github.repository }}/pulls \
            --jq '.[] | select(.head.sha == "${{ github.event.workflow_run.head_sha }}") | .number' \
            | head -1)

          if [ -z "$PR_NUMBER" ]; then
            echo "❌ PR 번호를 찾을 수 없습니다."
            exit 1
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "✅ PR 번호: $PR_NUMBER"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Request CodeRabbit Summary
        run: |
          gh pr comment ${{ steps.get_pr.outputs.pr_number }} --body "@coderabbitai review"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Wait for CodeRabbit Summary
        id: detect_summary
        continue-on-error: true
        timeout-minutes: 10
        run: |
          for i in {1..120}; do
            echo "[$i/120] Waiting for CodeRabbit summary..."
            PR_BODY=$(gh pr view ${{ steps.get_pr.outputs.pr_number }} --json body --jq .body)
            if [[ "$PR_BODY" == *"Summary by CodeRabbit"* ]]; then
              echo "✅ Summary found!"
              echo "$PR_BODY" > summary_section.html
              echo "summary_found=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 5
          done
          echo "⚠️ Timed out waiting for summary."
          echo "summary_found=false" >> $GITHUB_OUTPUT
          exit 1
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Grant execute permission to scripts
        run: |
          chmod +x .github/scripts/rn_version_manager.sh
          chmod +x .github/scripts/changelog_manager.py

      - name: Increment version and sync native files
        id: versioning
        run: |
          NEW_VERSION=$(./.github/scripts/rn_version_manager.sh increment)
          ./.github/scripts/rn_version_manager.sh sync
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Dynamic Summary Parsing and CHANGELOG Update
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          PR_NUMBER="${{ steps.get_pr.outputs.pr_number }}"
          VERSION="${{ steps.versioning.outputs.new_version }}"
          TIMESTAMP=$(date '+%Y-%m-%dT%H:%M:%SZ')

          echo "📝 CodeRabbit Summary 동적 파싱 시작..."

          # Python으로 동적 파싱
          cat > parse_changelog.py << 'EOF'
          import re
          import json
          import html
          import sys
          import os
          from datetime import datetime

          def extract_items_from_section(html_content, section_title):
              """특정 섹션의 아이템들을 추출"""
              print(f"📋 '{section_title}' 섹션에서 아이템 추출 중...")
              
              # 다양한 패턴으로 섹션 찾기
              patterns = [
                  f'<strong[^>]*>{re.escape(section_title)}[^<]*</strong>',
                  f'<li[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong>',
                  f'<p[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong></p>'
              ]
              
              section_match = None
              for pattern in patterns:
                  section_match = re.search(pattern, html_content, re.IGNORECASE)
                  if section_match:
                      print(f"✅ 패턴 매치: {pattern[:50]}...")
                      break
              
              if not section_match:
                  print(f"❌ '{section_title}' 섹션을 찾을 수 없습니다")
                  return []
              
              # 섹션 이후의 ul 태그 찾기
              after_section = html_content[section_match.end():]
              ul_match = re.search(r'<ul[^>]*>(.*?)</ul>', after_section, re.DOTALL)
              
              if not ul_match:
                  print(f"❌ '{section_title}' 섹션 이후 ul 태그를 찾을 수 없습니다")
                  return []
              
              # li 태그들에서 텍스트 추출
              ul_content = ul_match.group(1)
              li_items = re.findall(r'<li[^>]*>(.*?)</li>', ul_content, re.DOTALL)
              
              items = []
              for item in li_items:
                  # HTML 태그 제거하고 텍스트만 추출
                  clean_text = re.sub(r'<[^>]*>', '', item)
                  clean_text = html.unescape(clean_text).strip()
                  if clean_text:
                      items.append(clean_text)
                      print(f"  📝 아이템: {clean_text[:50]}...")
              
              print(f"✅ '{section_title}' 섹션에서 {len(items)}개 아이템 추출 완료")
              return items

          def detect_categories(html_content):
              """HTML에서 동적으로 카테고리 감지"""
              print("🔍 HTML에서 카테고리 감지 시작...")
              print(f"📄 HTML 내용 길이: {len(html_content)} characters")
              
              detected_categories = {}
              
              # strong 태그 안의 카테고리 제목들 찾기
              strong_texts = re.findall(r'<strong[^>]*>([^<]+)</strong>', html_content, re.IGNORECASE)
              print(f"🎯 발견된 strong 태그들: {strong_texts}")
              
              for strong_text in strong_texts:
                  clean_text = strong_text.strip()
                  print(f"🏷️ 처리 중인 카테고리: '{clean_text}'")
                  
                  items = extract_items_from_section(html_content, clean_text)
                  if items:
                      # 카테고리 키를 안전한 형태로 변환
                      safe_key = re.sub(r'[^a-zA-Z0-9가-힣]', '_', clean_text.lower()).strip('_')
                      if not safe_key:
                          safe_key = f"category_{len(detected_categories)}"
                      
                      print(f"✅ 카테고리 추가: '{clean_text}' -> '{safe_key}' ({len(items)}개 아이템)")
                      detected_categories[safe_key] = items
                  else:
                      print(f"❌ '{clean_text}' 카테고리에서 아이템을 찾을 수 없음")
              
              print(f"🎯 최종 감지된 카테고리 수: {len(detected_categories)}")
              return detected_categories

          def main():
              # 환경 변수에서 값 가져오기
              version = os.environ.get('VERSION')
              pr_number = int(os.environ.get('PR_NUMBER'))
              timestamp = os.environ.get('TIMESTAMP')
              
              try:
                  # HTML 파일 읽기
                  with open('summary_section.html', 'r', encoding='utf-8') as f:
                      html_content = f.read()
                  
                  print(f"📄 읽어온 HTML 내용 미리보기:")
                  print("=" * 50)
                  print(html_content[:500] + "..." if len(html_content) > 500 else html_content)
                  print("=" * 50)
                  
                  # 동적 카테고리 감지
                  categories = detect_categories(html_content)
                  
                  # 새로운 릴리즈 엔트리 생성
                  new_release = {
                      "version": version,
                      "timestamp": timestamp,
                      "pr_number": str(pr_number),
                      "changes": categories
                  }
                  
                  # CHANGELOG.json 업데이트
                  try:
                      with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                          changelog_data = json.load(f)
                  except (FileNotFoundError, json.JSONDecodeError):
                      changelog_data = {"releases": []}
                  
                  # 새 릴리즈를 맨 앞에 추가
                  changelog_data["releases"].insert(0, new_release)
                  
                  # 파일 저장
                  with open('CHANGELOG.json', 'w', encoding='utf-8') as f:
                      json.dump(changelog_data, f, indent=2, ensure_ascii=False)
                  
                  print("✅ CHANGELOG.json 업데이트 완료!")
                  print(f"📊 총 {len(categories)}개 카테고리, {sum(len(items) for items in categories.values())}개 변경사항")
                  
              except Exception as e:
                  print(f"❌ 파싱 오류: {e}")
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOF

          # 환경 변수 설정하고 Python 스크립트 실행
          export VERSION="$VERSION"
          export PR_NUMBER="$PR_NUMBER"
          export TIMESTAMP="$TIMESTAMP"

          python3 parse_changelog.py

      - name: Generate CHANGELOG.md from JSON
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          echo "📄 CHANGELOG.json에서 CHANGELOG.md 재생성 중..."

          python3 << 'PYTHON_SCRIPT'
          import json

          try:
              with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                  data = json.load(f)
              
              with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
                  f.write("# CHANGELOG\n\n")
                  f.write("이 파일은 워크플로우에 의해 자동으로 생성됩니다.\n")

                  for release in data['releases']:
                      f.write(f"## v{release['version']} ({release['timestamp'][0:10]})\n")
                      
                      # 카테고리별로 정리된 형식으로 출력 (Expo 방식)
                      for category_key, items in release['changes'].items():
                          if items:
                              # 카테고리명을 한국어로 변환
                              category_titles = {
                                  'chores': '작업 정리',
                                  'features': '새로운 기능', 
                                  'bug_fixes': '버그 수정',
                                  'documentation': '문서화',
                                  'refactor': '리팩토링',
                                  'style': '스타일링',
                                  'test': '테스트',
                                  'general': '일반'
                              }
                              
                              title = category_titles.get(category_key.lower(), category_key.replace('_', ' ').title())
                              f.write(f"\n**{title}**\n")
                              
                              for item in items:
                                  f.write(f"- {item}\n")
                      
                      f.write("\n---\n\n")
              
              print("✅ CHANGELOG.md 재생성 완료!")
              
          except Exception as e:
              print(f"❌ CHANGELOG.md 생성 실패: {e}")
              exit(1)
          PYTHON_SCRIPT

      - name: Generate PREVIOUS_CHANGES.md from JSON
        if: steps.detect_summary.outputs.summary_found == 'true'
        run: |
          echo "📄 PREVIOUS_CHANGES.md 생성 중..."

          if [ -f "CHANGELOG.json" ]; then
            # CHANGELOG.json에서 최신 버전을 제외한 이전 버전들로 PREVIOUS_CHANGES.md 생성 (Expo 방식)
            jq -r '
              "# 이전 변경사항\n\n" +
              (.releases[1:] | map(
                "## [" + .version + "] - " + .timestamp[0:10] + "\n" +
                (.changes | to_entries | map(
                  "\n**" + (
                    if .key == "chores" then "작업 정리"
                    elif .key == "features" then "새로운 기능"
                    elif .key == "bug_fixes" then "버그 수정"
                    elif .key == "documentation" then "문서화"
                    elif .key == "refactor" then "리팩토링"
                    elif .key == "style" then "스타일링"
                    elif .key == "test" then "테스트"
                    else (.key | gsub("_"; " ") | ascii_upcase)
                    end
                  ) + "**\n" + 
                  (.value | map("- " + .) | join("\n"))
                ) | join("\n")) + "\n\n---\n"
              ) | join("\n"))
            ' CHANGELOG.json > PREVIOUS_CHANGES.md
            
            echo "✅ PREVIOUS_CHANGES.md 생성 완료"
          else
            echo "# 이전 변경사항" > PREVIOUS_CHANGES.md
            echo "" >> PREVIOUS_CHANGES.md
            echo "아직 이전 변경사항이 없습니다." >> PREVIOUS_CHANGES.md
            echo "⚠️ CHANGELOG.json이 없어 기본 PREVIOUS_CHANGES.md 생성"
          fi

      - name: Commit and push CHANGELOG updates
        run: |
          git add package.json ios/Wit/Info.plist android/app/build.gradle CHANGELOG.json CHANGELOG.md PREVIOUS_CHANGES.md
          if ! git diff --staged --quiet; then
            git commit -m "chore: update CHANGELOG to v${{ steps.versioning.outputs.new_version }} [skip ci]"
            git push origin main
          else
            echo "No CHANGELOG changes to commit."
          fi

      - name: Create and push Git tag
        run: |
          git tag "v${{ steps.versioning.outputs.new_version }}"
          git push origin "v${{ steps.versioning.outputs.new_version }}"

      - name: Save Release Notes for deployment
        id: release_notes
        run: |
          # CHANGELOG.md에서 최신 릴리즈 부분만 추출
          awk '/## v${{ steps.versioning.outputs.new_version }}/{flag=1; next}/## v/{flag=0}flag' CHANGELOG.md > release_notes.txt
          cat release_notes.txt

      - name: Upload Release Notes artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-${{ steps.versioning.outputs.new_version }}
          path: release_notes.txt

      - name: 🎉 CHANGELOG Update Success
        run: |
          echo "✅ CHANGELOG 업데이트가 성공했습니다!"
          echo "📦 새 버전: v${{ steps.versioning.outputs.new_version }}"
          echo "📋 다음 단계: TestFlight 배포 워크플로우가 자동으로 시작됩니다."
