# ===================================================================
# Wit 프로젝트 자동 체인지로그 관리 워크플로우
# ===================================================================
#
# 이 워크플로우는 main -> release PR이 생성될 때 CodeRabbit AI의 리뷰를
# 자동으로 감지하고 파싱하여 CHANGELOG.json과 CHANGELOG.md를 업데이트합니다.
#
# 작동 방식:
# 1. main -> release PR 생성 시 트리거
# 2. iOS 빌드 테스트 먼저 실행 (빠른 피드백)
# 3. 버전 자동 증가 및 네이티브 파일 동기화
# 4. CodeRabbit Summary가 생성될 때까지 최대 10분 대기
# 5. Summary 내용을 파싱하여 CHANGELOG 파일들 업데이트
# 6. PREVIOUS_CHANGES.md 및 README.md 자동 업데이트
# 7. PR 자동 머지 후 TestFlight 배포 트리거
#
# 지원 기능:
# - React Native 프로젝트 버전 관리 (package.json, Info.plist, build.gradle)
# - CodeRabbit Summary의 실시간 파싱 및 카테고리 분류
# - JSON 및 Markdown 형식의 체인지로그 자동 생성
# - README.md 및 PREVIOUS_CHANGES.md 자동 업데이트
# - PR 자동 머지 후 TestFlight 배포 파이프라인 트리거
#
# ===================================================================

name: 📝 CHANGELOG Update

on:
  workflow_run:
    workflows: ['🧪 Build Test']
    types:
      - completed

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job 1: CodeRabbit Summary 감지
  detect-summary:
    name: 📋 CodeRabbit Summary 감지
    runs-on: macos-14
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      summary_found: ${{ steps.detect_summary.outputs.summary_found }}
      pr_number: ${{ steps.get_pr.outputs.pr_number }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get PR Number from workflow_run
        id: get_pr
        run: |
          # workflow_run에서 PR 번호 추출
          PR_NUMBER=$(gh api repos/${{ github.repository }}/pulls \
            --jq '.[] | select(.head.sha == "${{ github.event.workflow_run.head_sha }}") | .number' \
            | head -1)

          if [ -z "$PR_NUMBER" ]; then
            echo "❌ PR 번호를 찾을 수 없습니다"
            exit 1
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "✅ PR 번호: $PR_NUMBER"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Grant execute permission to scripts
        run: |
          echo "📋 스크립트 파일 권한 설정 중..."
          if [ -f ".github/scripts/rn_version_manager.sh" ]; then
            chmod +x .github/scripts/rn_version_manager.sh
            echo "✅ rn_version_manager.sh 권한 설정 완료"
          else
            echo "❌ rn_version_manager.sh 파일을 찾을 수 없습니다!"
            exit 1
          fi

      - name: Request CodeRabbit Summary
        run: |
          echo "🤖 CodeRabbit에게 리뷰 요청 중..."
          gh pr comment ${{ steps.get_pr.outputs.pr_number }} --body "@coderabbitai review"
          echo "✅ CodeRabbit 리뷰 요청 완료"
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Wait for CodeRabbit Summary (Enhanced Detection)
        id: detect_summary
        continue-on-error: true
        timeout-minutes: 10
        run: |
          PR_NUMBER="${{ steps.get_pr.outputs.pr_number }}"
          MAX_ATTEMPTS=120  # 10분 = 120 * 5초
          ATTEMPT=0

          echo "🔍 PR #$PR_NUMBER에서 CodeRabbit Summary 업데이트 감지 시작..."
          echo "최대 대기 시간: 10분 (5초마다 체크)"

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "[$ATTEMPT/$MAX_ATTEMPTS] CodeRabbit Summary 확인 중... ($(date '+%H:%M:%S'))"
            
            # GitHub API로 PR HTML 가져오기
            curl -s -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
                 -H "Accept: application/vnd.github.v3.html" \
                 "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUMBER}" \
                 > pr_content.html
            
            # "No description provided" 체크
            if grep -q "No description provided" pr_content.html; then
              echo "❌ 아직 'No description provided' 상태입니다"
            elif grep -q "Summary by CodeRabbit" pr_content.html; then
              echo "✅ CodeRabbit Summary 발견! 파싱을 시작합니다"
              echo "summary_found=true" >> $GITHUB_OUTPUT
              break
            else
              echo "⏳ CodeRabbit Summary 아직 없음"
            fi
            
            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 5
            fi
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "⚠️ 10분 대기 후에도 CodeRabbit Summary를 찾을 수 없습니다"
            echo "summary_found=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}

      - name: Upload PR content for next job
        if: steps.detect_summary.outputs.summary_found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: pr-content-${{ steps.get_pr.outputs.pr_number }}
          path: pr_content.html
          retention-days: 1

  # Job 2: 버전 업데이트 및 CHANGELOG 생성
  update-changelog:
    name: 📝 버전 업데이트 및 CHANGELOG 생성
    runs-on: macos-14
    needs: detect-summary
    if: needs.detect-summary.outputs.summary_found == 'true'
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Download PR content
        uses: actions/download-artifact@v4
        with:
          name: pr-content-${{ needs.detect-summary.outputs.pr_number }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Grant execute permission to scripts
        run: |
          echo "📋 스크립트 파일 권한 설정 중..."
          if [ -f ".github/scripts/rn_version_manager.sh" ]; then
            chmod +x .github/scripts/rn_version_manager.sh
            echo "✅ rn_version_manager.sh 권한 설정 완료"
          else
            echo "❌ rn_version_manager.sh 파일을 찾을 수 없습니다!"
            exit 1
          fi

      - name: 현재 버전 확인
        id: current_version
        run: |
          CURRENT_VERSION=$(./.github/scripts/rn_version_manager.sh get)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "현재 버전: $CURRENT_VERSION"

      - name: 새 버전 계산 (patch 버전 증가)
        id: version
        run: |
          VERSION="${{ steps.current_version.outputs.current_version }}"

          # patch 버전 증가 (1.0.54 → 1.0.55)
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "새 버전: $NEW_VERSION"

      - name: package.json 및 네이티브 파일 업데이트
        run: |
          # rn_version_manager.sh를 사용하여 버전 업데이트
          NEW_VERSION=$(./.github/scripts/rn_version_manager.sh increment)
          ./.github/scripts/rn_version_manager.sh sync
          echo "package.json 및 네이티브 파일 업데이트 완료: $NEW_VERSION"

      - name: 동적 Summary 파싱 및 CHANGELOG.json 업데이트
        if: needs.detect-summary.outputs.summary_found == 'true'
        run: |
          PR_NUMBER="${{ needs.detect-summary.outputs.pr_number }}"
          VERSION="${{ steps.version.outputs.new_version }}"
          TODAY=$(date '+%Y-%m-%d')
          TIMESTAMP=$(date '+%Y-%m-%dT%H:%M:%SZ')

          echo "📝 CodeRabbit Summary 동적 파싱 시작..."

          # Summary 섹션 추출 (changelog-update.yml과 완전히 동일한 방식)
          sed -n '/<h2[^>]*>Summary by CodeRabbit<\/h2>/,/<\/div>/p' pr_content.html > summary_section.html

          # Summary가 제대로 추출되었는지 확인
          echo "📄 추출된 Summary 섹션 크기: $(wc -c < summary_section.html) bytes"
          if [ $(wc -c < summary_section.html) -lt 100 ]; then
            echo "⚠️ Summary 섹션이 너무 작습니다. 전체 PR 내용에서 다시 추출 시도..."
            grep -A 50 "Summary by CodeRabbit" pr_content.html > summary_section.html
          fi

          # Raw summary 저장 (백업용)
          cat summary_section.html | sed 's/<[^>]*>//g' | sed 's/&nbsp;/ /g; s/&amp;/\&/g; s/&lt;/</g; s/&gt;/>/g; s/&quot;/"/g' > raw_summary.txt

          echo "🔍 동적 카테고리 추출 중..."
          echo "📄 Summary 섹션 미리보기:"
          head -10 summary_section.html

          # Python으로 동적 파싱 (changelog-update.yml과 완전히 동일)
          cat > parse_changelog.py << 'EOF'
          import re
          import json
          import html
          import sys
          import os
          from datetime import datetime

          def extract_items_from_section(html_content, section_title):
              """특정 섹션의 아이템들을 추출"""
              print(f"📋 '{section_title}' 섹션에서 아이템 추출 중...")
              
              # 다양한 패턴으로 섹션 찾기
              patterns = [
                  f'<strong[^>]*>{re.escape(section_title)}[^<]*</strong>',  # 직접 strong 태그
                  f'<li[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong>',  # li > strong
                  f'<p[^>]*><strong[^>]*>{re.escape(section_title)}[^<]*</strong></p>'  # p > strong
              ]
              
              section_match = None
              for pattern in patterns:
                  section_match = re.search(pattern, html_content, re.IGNORECASE)
                  if section_match:
                      print(f"✅ 패턴 매치: {pattern[:50]}...")
                      break
              
              if not section_match:
                  print(f"❌ '{section_title}' 섹션을 찾을 수 없습니다")
                  return []
              
              # 섹션 이후의 ul 태그 찾기
              after_section = html_content[section_match.end():]
              ul_match = re.search(r'<ul[^>]*>(.*?)</ul>', after_section, re.DOTALL)
              
              if not ul_match:
                  print(f"❌ '{section_title}' 섹션 이후 ul 태그를 찾을 수 없습니다")
                  return []
              
              # li 태그들에서 텍스트 추출
              ul_content = ul_match.group(1)
              li_items = re.findall(r'<li[^>]*>(.*?)</li>', ul_content, re.DOTALL)
              
              items = []
              for item in li_items:
                  # HTML 태그 제거하고 텍스트만 추출
                  clean_text = re.sub(r'<[^>]*>', '', item)
                  clean_text = html.unescape(clean_text).strip()
                  if clean_text:
                      items.append(clean_text)
                      print(f"  📝 아이템: {clean_text[:50]}...")
              
              print(f"✅ '{section_title}' 섹션에서 {len(items)}개 아이템 추출 완료")
              return items

          def detect_categories(html_content):
              """HTML에서 동적으로 카테고리 감지 - AI가 생성하는 모든 카테고리 수용"""
              print("🔍 HTML에서 카테고리 감지 시작...")
              print(f"📄 HTML 내용 길이: {len(html_content)} characters")
              
              detected_categories = {}
              
              # strong 태그 안의 카테고리 제목들 찾기
              strong_texts = re.findall(r'<strong[^>]*>([^<]+)</strong>', html_content, re.IGNORECASE)
              print(f"🎯 발견된 strong 태그들: {strong_texts}")
              
              for strong_text in strong_texts:
                  clean_text = strong_text.strip()
                  print(f"🏷️ 처리 중인 카테고리: '{clean_text}'")
                  
                  # AI가 생성한 카테고리 제목을 그대로 사용
                  items = extract_items_from_section(html_content, clean_text)
                  if items:
                      # 카테고리 키를 안전한 형태로 변환 (소문자, 공백을 언더스코어로)
                      safe_key = re.sub(r'[^a-zA-Z0-9가-힣]', '_', clean_text.lower()).strip('_')
                      if not safe_key:  # 안전한 키가 생성되지 않으면 fallback
                          safe_key = f"category_{len(detected_categories)}"
                      
                      print(f"✅ 카테고리 추가: '{clean_text}' -> '{safe_key}' ({len(items)}개 아이템)")
                      detected_categories[safe_key] = items
                  else:
                      print(f"❌ '{clean_text}' 카테고리에서 아이템을 찾을 수 없음")
              
              print(f"🎯 최종 감지된 카테고리 수: {len(detected_categories)}")
              return detected_categories

          def main():
              # 환경 변수에서 값 가져오기
              version = os.environ.get('VERSION')
              today = os.environ.get('TODAY')
              pr_number = int(os.environ.get('PR_NUMBER'))
              timestamp = os.environ.get('TIMESTAMP')
              
              try:
                  # HTML 파일 읽기
                  with open('summary_section.html', 'r', encoding='utf-8') as f:
                      html_content = f.read()
                  
                  print(f"📄 읽어온 HTML 내용 미리보기:")
                  print("=" * 50)
                  print(html_content[:500] + "..." if len(html_content) > 500 else html_content)
                  print("=" * 50)
                  
                  # 동적 카테고리 감지
                  categories = detect_categories(html_content)
                  
                  print("🎯 감지된 카테고리들:")
                  for key, items in categories.items():
                      print(f"  - {key}: ({len(items)}개 항목)")
                      for item in items[:3]:  # 첫 3개 아이템만 미리보기
                          print(f"    • {item[:80]}...")
                  
                  # Raw summary 읽기
                  with open('raw_summary.txt', 'r', encoding='utf-8') as f:
                      raw_summary = f.read().strip()
                  
                  # 새로운 릴리즈 엔트리 생성
                  new_release = {
                      "version": version,
                      "date": today,
                      "pr_number": pr_number,
                      "raw_summary": raw_summary,
                      "parsed_changes": categories
                  }
                  
                  # CHANGELOG.json 업데이트
                  try:
                      with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                          changelog_data = json.load(f)
                  except (FileNotFoundError, json.JSONDecodeError):
                      changelog_data = {
                          "metadata": {
                              "lastUpdated": timestamp,
                              "currentVersion": version,
                              "totalReleases": 0
                          },
                          "releases": []
                      }
                  
                  # 메타데이터 업데이트
                  changelog_data["metadata"]["lastUpdated"] = timestamp
                  changelog_data["metadata"]["currentVersion"] = version
                  changelog_data["metadata"]["totalReleases"] = len(changelog_data["releases"]) + 1
                  
                  # 새 릴리즈를 맨 앞에 추가
                  changelog_data["releases"].insert(0, new_release)
                  
                  # 파일 저장
                  with open('CHANGELOG.json', 'w', encoding='utf-8') as f:
                      json.dump(changelog_data, f, indent=2, ensure_ascii=False)
                  
                  print("✅ CHANGELOG.json 업데이트 완료!")
                  print(f"📊 총 {len(categories)}개 카테고리, {sum(len(items) for items in categories.values())}개 변경사항")
                  
              except Exception as e:
                  print(f"❌ 파싱 오류: {e}")
                  sys.exit(1)

          if __name__ == "__main__":
              main()
          EOF

          # 환경 변수 설정하고 Python 스크립트 실행
          export VERSION="$VERSION"
          export TODAY="$TODAY"
          export PR_NUMBER="$PR_NUMBER"
          export TIMESTAMP="$TIMESTAMP"

          python3 parse_changelog.py

      - name: CHANGELOG.md 재생성
        if: needs.detect-summary.outputs.summary_found == 'true'
        run: |
          echo "📄 CHANGELOG.json에서 CHANGELOG.md 재생성 중..."

          python3 << 'PYTHON_SCRIPT'
          import json
          import traceback

          try:
              with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                  data = json.load(f)
              
              print(f"🔍 CHANGELOG.json 구조 확인:")
              print(f"  - 키들: {list(data.keys())}")
              if 'releases' in data and data['releases']:
                  print(f"  - 첫 번째 릴리즈 키들: {list(data['releases'][0].keys())}")
                  if 'parsed_changes' in data['releases'][0]:
                      print(f"  - parsed_changes 키들: {list(data['releases'][0]['parsed_changes'].keys())}")
                  else:
                      print("  - ❌ parsed_changes 키가 없습니다!")
              
              with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
                  f.write("# Changelog\n\n")

                  for release in data.get('releases', []):
                      f.write(f"## [{release.get('version', 'Unknown')}] - {release.get('date', 'Unknown')}\n\n")
                      
                      # AI가 생성한 모든 카테고리를 그대로 출력
                      for category_key, items in release['parsed_changes'].items():
                          if items:
                              # 카테고리 키를 제목으로 변환 (언더스코어를 공백으로, 첫 글자 대문자)
                              title = category_key.replace('_', ' ').title()
                              
                              f.write(f"**{title}**\n")
                              
                              for item in items:
                                  f.write(f"- {item}\n")
                              f.write("\n")
                      
                      f.write("---\n\n")
              
              print("✅ CHANGELOG.md 재생성 완료!")
              
          except Exception as e:
              print(f"❌ CHANGELOG.md 생성 실패: {e}")
              print(f"❌ 상세 오류:")
              traceback.print_exc()
              
              # 디버깅을 위해 CHANGELOG.json 내용 출력
              try:
                  with open('CHANGELOG.json', 'r', encoding='utf-8') as f:
                      content = f.read()
                      print(f"📄 CHANGELOG.json 내용:")
                      print(content[:1000] + "..." if len(content) > 1000 else content)
              except:
                  print("❌ CHANGELOG.json 파일을 읽을 수 없습니다.")
              
              exit(1)
          PYTHON_SCRIPT

      - name: 변경사항 커밋 및 푸시
        if: needs.detect-summary.outputs.summary_found == 'true'
        run: |
          # 변경사항 추가
          git add package.json ios/Wit/Info.plist android/app/build.gradle CHANGELOG.json CHANGELOG.md

          # 변경사항이 있는지 확인
          if git diff --staged --quiet; then
            echo "📝 변경사항이 없습니다"
          else
            git commit -m "chore: 버전 ${{ steps.version.outputs.new_version }} (PR #${{ needs.detect-summary.outputs.pr_number }}) [skip ci]"
            git push origin main
            echo "✅ 변경사항이 성공적으로 커밋되었습니다"
          fi

      - name: Create and push Git tag
        if: needs.detect-summary.outputs.summary_found == 'true'
        run: |
          VERSION="v${{ steps.version.outputs.new_version }}"

          echo "🏷️ Git 태그 생성 중: $VERSION"

          # 기존 태그 존재 여부 확인
          if git tag -l "$VERSION" | grep -q "$VERSION"; then
            echo "⚠️ 태그 $VERSION이 이미 존재합니다. 기존 태그를 삭제하고 새로 생성합니다."
            git tag -d "$VERSION" || true
            git push origin --delete "$VERSION" || true
          fi

          # 새 태그 생성 및 푸시
          git tag "$VERSION"
          git push origin "$VERSION"

          echo "✅ Git 태그 $VERSION 생성 및 푸시 완료"

      - name: 업데이트 완료 알림
        run: |
          if [ "${{ needs.detect-summary.outputs.summary_found }}" == "true" ]; then
            echo "✅ CHANGELOG 업데이트 완료!"
            echo "📦 새 버전: ${{ steps.version.outputs.new_version }}"
            echo "🔗 PR: #${{ needs.detect-summary.outputs.pr_number }}"
            echo "📄 package.json, CHANGELOG.json 및 CHANGELOG.md가 업데이트되었습니다"
            echo "🎯 동적 카테고리 파싱으로 AI 생성 콘텐츠 유연하게 처리됨"
          else
            echo "⚠️ CodeRabbit Summary를 찾을 수 없어 업데이트를 건너뛰었습니다"
          fi

      - name: 정리
        run: |
          rm -f pr_content.html summary_section.html raw_summary.txt parse_changelog.py
